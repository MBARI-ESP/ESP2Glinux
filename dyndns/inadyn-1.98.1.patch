diff -ru inadyn-1.98.1/include/dyndns.h inadyn-mbari7/include/dyndns.h
--- inadyn-1.98.1/include/dyndns.h	2011-07-18 06:05:26.000000000 -0700
+++ inadyn-mbari7/include/dyndns.h	2013-03-02 17:24:55.514180549 -0800
@@ -53,9 +53,7 @@
 /*test values*/
 #define DYNDNS_DEFAULT_DEBUG_LEVEL	1
 #define DYNDNS_DEFAULT_CONFIG_FILE	"/etc/inadyn.conf"
-#define DYNDNS_RUNTIME_DATA_DIR		"/var/run/inadyn"
-#define DYNDNS_DEFAULT_CACHE_FILE	DYNDNS_RUNTIME_DATA_DIR"/inadyn.cache"
-#define DYNDNS_DEFAULT_PIDFILE		DYNDNS_RUNTIME_DATA_DIR"/inadyn.pid"
+#define DYNDNS_DEFAULT_PIDFILE		"/var/run/inadyn.pid"
 
 #define DYNDNS_MY_USERNAME		"test"
 #define DYNDNS_MY_PASSWD		"test"
@@ -189,16 +187,16 @@
 
 
 /* SOME DEFAULT CONFIGURATIONS */
-#define DYNDNS_DEFAULT_SLEEP			(120) /* sec */
-#define DYNDNS_MIN_SLEEP			(30)  /* sec */
+#define DYNDNS_DEFAULT_SLEEP		(60) /* sec */
+#define DYNDNS_MIN_SLEEP			(30) /* sec */
 #define DYNDNS_MAX_SLEEP			(10 * 24 * 3600) /* 10 days in sec */
-#define DYNDNS_MY_FORCED_UPDATE_PERIOD_S	(30 * 24 * 3600) /* 30 days in sec */
-#define DYNDNS_DEFAULT_CMD_CHECK_PERIOD		(1)    /* sec */
+#define DYNDNS_MY_FORCED_UPDATE_PERIOD_S	(7 * 24 * 3600) /* 7 days in sec */
+#define DYNDNS_DEFAULT_CMD_CHECK_PERIOD		(5)    /* sec */
 #define DYNDNS_DEFAULT_ITERATIONS		0      /* Forever */
 #define DYNDNS_HTTP_RESPONSE_BUFFER_SIZE	(2500) /* Bytes */
 #define DYNDNS_HTTP_REQUEST_BUFFER_SIZE		(2500) /* Bytes */
-#define DYNDNS_MAX_ALIAS_NUMBER			10 /* maximum number of aliases per server that can be maintained */
-#define DYNDNS_MAX_SERVER_NUMBER		5  /* maximum number of servers that can be maintained */
+#define DYNDNS_MAX_ALIAS_NUMBER			5 /* maximum number of aliases per server that can be maintained */
+#define DYNDNS_MAX_SERVER_NUMBER		4 /* maximum number of servers that can be maintained */
 
 /* local configs */
 #define DYNDNS_MY_IP_ADDRESS_LENGTH		20  /* chars */
@@ -299,23 +297,34 @@
 	gid_t gid;
 } USER_INFO;
 
+typedef struct ifaceList
+{
+  struct ifaceList *next;
+  char *name;
+} ifaceList;
+
 typedef struct DYN_DNS_CLIENT
 {
 	char *cfgfile;
 	char *pidfile;
+    char *cachefile;
 	char *external_command;
+    char *onNetErr;
 
 	DYN_DNS_CMD  cmd;
-	int          sleep_sec; /* time between 2 updates*/
+	int          sleep_sec; /* time between 2 updates */
 	int          forced_update_period_sec;
 	int          times_since_last_update;
 	int          forced_update_times; /* the same forced update period counted in sleep periods*/
+	int          check_ip_period_sec;
+	int          secs_since_last_check;
 	int          cmd_check_period; /*time to wait for a command*/
 	int          total_iterations;
 	int          num_iterations;
 	char        *interface;
 	BOOL         initialized;
 	BOOL         run_in_background;
+    BOOL		 restart;
 	BOOL         debug_to_syslog;
 	BOOL         change_persona;
 
@@ -330,8 +339,8 @@
 	USER_INFO         sys_usr_info; /* info about the current account running inadyn */
 	DYNDNS_INFO_TYPE  info[DYNDNS_MAX_SERVER_NUMBER]; /* servers, names, passwd */
 	int               info_count;
+	ifaceList        *lastIface;  /* circular list of interfaces that could have our public IP address */
 
-	BOOL abort_on_network_errors;
 	BOOL force_addr_update;
 	BOOL use_proxy;
 	BOOL abort;
diff -ru inadyn-1.98.1/include/errorcode.h inadyn-mbari7/include/errorcode.h
--- inadyn-1.98.1/include/errorcode.h	2011-07-18 06:05:26.000000000 -0700
+++ inadyn-mbari7/include/errorcode.h	2013-03-02 17:24:55.514180549 -0800
@@ -37,6 +37,7 @@
 	RC_IP_OBJECT_NOT_INITIALIZED = 0x16,
 	RC_IP_OS_SOCKET_INIT_FAILED = 0x17,
 	RC_IP_SOCKET_BIND_ERROR = 0x18,
+        RC_NET_INTERFACES_DOWN = 0x19,
 
 	RC_TCP_OBJECT_NOT_INITIALIZED = 0x20,
 
@@ -67,6 +68,7 @@
 	RC_FILE_IO_READ_ERROR = 0x71,
 	RC_FILE_IO_OUT_OF_BUFFER = 0x72,
 
+        RC_STOP = 0xfe,
 	RC_RESTART = 0xff,
 } RC_TYPE;
 
diff -ru inadyn-1.98.1/include/os.h inadyn-mbari7/include/os.h
--- inadyn-1.98.1/include/os.h	2011-07-18 06:05:26.000000000 -0700
+++ inadyn-mbari7/include/os.h	2013-03-02 17:24:55.522180629 -0800
@@ -150,6 +150,10 @@
 
 RC_TYPE os_change_persona(OS_USER_INFO *p_usr_info);
 
+/** fill in buffer ip with the address of the specified network interface
+*/
+RC_TYPE os_ifaceIP (const char *iface, struct in_addr *ip);
+
 /* Blocks a thread the specified number of milliseconds*/
 void os_sleep_ms(int ms);
 
@@ -216,6 +220,19 @@
  */
 RC_TYPE os_shell_execute(char *p_cmd);
 
+/**
+ * Execute command capturing output
+ *  returns opened file * for reading output
+ */
+FILE *os_pipe_out(char * p_cmd);
+
+/**
+ * Execute command capturing output
+ *   returns return code from command pipe
+ */
+RC_TYPE os_pipe_close(FILE *pipe);
+
+
 #ifdef __cplusplus
 }
 #endif
diff -ru inadyn-1.98.1/Makefile inadyn-mbari7/Makefile
--- inadyn-1.98.1/Makefile	2011-07-18 06:05:26.000000000 -0700
+++ inadyn-mbari7/Makefile	2013-03-02 19:35:45.584263307 -0800
@@ -1,7 +1,7 @@
 # Makefile for INADYN, a simple and small ddns client.          -*-Makefile-*-
 
 #VERSION      ?= $(shell git tag -l | tail -1)
-VERSION      ?= 1.98.1
+VERSION      ?= 1.98.1-mbari7
 NAME          = inadyn
 EXEC          = src/$(NAME)
 PKG           = $(NAME)-$(VERSION)
@@ -27,49 +27,48 @@
 		src/os.o src/os_psos.o src/tcp.o src/inadyn_cmd.o
 OBJS	      = $(BASE_OBJS) $(CFG_OBJ) $(EXTRA_OBJS)
 CFLAGS        = -Iinclude -DVERSION_STRING=\"$(VERSION)\" $(CFG_INC) $(EXTRA_CFLAGS)
-CFLAGS       += -O2 -W -Wall
+COPTS	      = -Os -W -Wall
+CFLAGS       += $(COPTS)
 LDLIBS       += -lresolv $(EXTRA_LIBS)
 DISTFILES     = README COPYING LICENSE
 
 # Pattern rules
 .c.o:
-	@printf "  CC      $@\n"
-	@$(CC) $(CFLAGS) $(CPPFLAGS) -c -o $@ $<
+	$(CC) $(CFLAGS) $(CPPFLAGS) -c -o $@ $<
 
 # Build rules
 all: $(EXEC)
 
 $(EXEC): $(OBJS)
-	@printf "  LINK    $@\n"
-	@$(CC) $(CFLAGS) $(LDFLAGS) -o $@ $(OBJS) $(LDLIBS)
+	$(CC) $(CFLAGS) $(LDFLAGS) -o $@ $(OBJS) $(LDLIBS)
 
 install: $(EXEC)
-	@install -d $(DESTDIR)$(prefix)/sbin
-	@install -d $(DESTDIR)$(sysconfdir)
-	@install -d $(DESTDIR)$(datadir)
-	@install -d $(DESTDIR)$(mandir)/man8
-	@install -d $(DESTDIR)$(mandir)/man5
-	@install -m 0755 $(EXEC) $(DESTDIR)$(prefix)/sbin/
-	@install -m 0644 man/$(MAN5) $(DESTDIR)$(mandir)/man5/$(MAN5)
-	@install -m 0644 man/$(MAN8) $(DESTDIR)$(mandir)/man8/$(MAN8)
-	@for file in $(DISTFILES); do \
+	install -d $(DESTDIR)$(prefix)/sbin
+	install -d $(DESTDIR)$(sysconfdir)
+	install -d $(DESTDIR)$(datadir)
+	install -d $(DESTDIR)$(mandir)/man8
+	install -d $(DESTDIR)$(mandir)/man5
+	install -m 0755 $(EXEC) $(DESTDIR)$(prefix)/sbin/
+	install -m 0644 man/$(MAN5) $(DESTDIR)$(mandir)/man5/$(MAN5)
+	install -m 0644 man/$(MAN8) $(DESTDIR)$(mandir)/man8/$(MAN8)
+	for file in $(DISTFILES); do \
 		install -m 0644 $$file $(DESTDIR)$(datadir)/$$file; \
 	done
 
 uninstall:
-	-@$(RM) $(DESTDIR)$(prefix)/sbin/$(EXEC)
-	-@$(RM) -r $(DESTDIR)$(datadir)
-	-@$(RM) $(DESTDIR)$(mandir)/man5/$(MAN5)
-	-@$(RM) $(DESTDIR)$(mandir)/man8/$(MAN8)
+	$(RM) $(DESTDIR)$(prefix)/sbin/$(EXEC)
+	$(RM) -r $(DESTDIR)$(datadir)
+	$(RM) $(DESTDIR)$(mandir)/man5/$(MAN5)
+	$(RM) $(DESTDIR)$(mandir)/man8/$(MAN8)
 
 clean:
-	-@$(RM) $(OBJS) $(EXEC)
+	$(RM) $(OBJS) $(EXEC)
 
 distclean:
-	-@$(RM) $(OBJS) core $(EXEC) *.o *.map .*.d *.out tags TAGS
+	$(RM) $(OBJS) core $(EXEC) *.o *.map .*.d *.out tags TAGS
 
 dist:
 	@echo "Building bzip2 tarball of $(PKG) in parent dir..."
 	git archive --format=tar --prefix=$(PKG)/ $(VERSION) | bzip2 >../$(ARCHIVE)
-	@(cd ..; md5sum $(ARCHIVE) | tee $(ARCHIVE).md5)
+	(cd ..; md5sum $(ARCHIVE) | tee $(ARCHIVE).md5)
 
diff -ru inadyn-1.98.1/src/dyndns.c inadyn-mbari7/src/dyndns.c
--- inadyn-1.98.1/src/dyndns.c	2011-07-18 06:05:26.000000000 -0700
+++ inadyn-mbari7/src/dyndns.c	2013-03-02 19:26:49.002866469 -0800
@@ -2,6 +2,8 @@
  *
  * Copyright (C) 2003-2004  Narcis Ilisei <inarcis2002@hotpop.com>
  * Copyright (C) 2006  Steve Horbachuk
+ * Revised:  Feb 8, 2012  brent@mbari.org
+ *    added option to read public IP address from specified network interface(s)
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License
@@ -438,10 +440,7 @@
 	p_tr->req_len = get_req_for_ip_server(p_self, servernum,
 					      p_self->info[servernum].p_dns_system->p_specific_data);
 	if (p_self->dbg.level > 2)
-	{
-		logit(LOG_DEBUG, MODULE_TAG "Querying DDNS server for my public IP#:");
-		logit(LOG_DEBUG, MODULE_TAG "%s", p_self->p_req_buffer);
-	}
+		logit(LOG_DEBUG, MODULE_TAG "DDNS reports public IP# as %s", p_self->p_req_buffer);
 	p_tr->p_req = (char*) p_self->p_req_buffer;
 	p_tr->p_rsp = (char*) p_self->p_work_buffer;
 	p_tr->max_rsp_len = p_self->work_buffer_size - 1; /* Save place for terminating \0 in string. */
@@ -454,6 +453,25 @@
 
 	return rc;
 }
+
+
+static int setMyIP(DYN_DNS_CLIENT *p_self, const char *newIPstr)
+{
+	int i, numChanged;
+    DYNDNS_INFO_TYPE *info0 = p_self->info;
+    DYNDNS_INFO_TYPE *info = info0;
+	for (numChanged = 0, i = 0; i < p_self->info_count; i++, info++)
+	    if ((info0->my_ip_has_changed = info->my_ip_has_changed = 
+                strncmp(info->my_ip_address.name, newIPstr, DYNDNS_SERVER_NAME_LENGTH) != 0)) {
+            strncpy(info->my_ip_address.name, newIPstr, DYNDNS_SERVER_NAME_LENGTH);
+            numChanged++;
+        }
+	if (!numChanged && p_self->dbg.level > 1)
+	  logit(LOG_INFO,MODULE_TAG "IP# remains %s",newIPstr);
+	return numChanged;
+}
+
+
 /*
   Read in 4 integers the ip addr numbers.
   construct then the IP address from those numbers.
@@ -463,10 +481,9 @@
 static RC_TYPE do_parse_my_ip_address(DYN_DNS_CLIENT *p_self, int servernum)
 {
 	int ip1 = 0, ip2 = 0, ip3 = 0, ip4 = 0;
-	int count, i;
+	int count;
 	char *p_ip;
 	char *p_current_str = p_self->http_tr.p_rsp;
-	BOOL found;
 	char new_ip_str[IP_V4_MAX_LENGTH];
 
 	(void)servernum;
@@ -476,7 +493,6 @@
 		return RC_INVALID_POINTER;
 	}
 
-	found = FALSE;
 	do
 	{
 		/* Try to find first decimal number (begin of IP) */
@@ -493,42 +509,15 @@
 			{
 				p_current_str = p_ip + 1;
 			}
-			else
-			{
-				/* FIRST occurence of a valid IP found */
-				found = TRUE;
-				break;
-			}
+			else	/* FIRST occurence of a valid IP found */
+            {
+				sprintf(new_ip_str, DYNDNS_IP_ADDR_FORMAT, ip1, ip2, ip3, ip4);
+				setMyIP(p_self, new_ip_str);
+                return RC_OK;
+            }
 		}
 	}
 	while (p_ip != NULL);
-
-	if (found)
-	{
-		int anychange = 0;
-
-		for (i = 0; i < p_self->info_count; i++)
-		{
-			DYNDNS_INFO_TYPE *info = &p_self->info[i];
-
-			sprintf(new_ip_str, DYNDNS_IP_ADDR_FORMAT, ip1, ip2, ip3, ip4);
-
-			info->my_ip_has_changed = strcmp(info->my_ip_address.name, new_ip_str) != 0;
-			if (info->my_ip_has_changed)
-			{
-				anychange++;
-				strcpy(info->my_ip_address.name, new_ip_str);
-			}
-		}
-
-		if (!anychange)
-		{
-			logit(LOG_INFO, MODULE_TAG "No IP# change detected, still at %s", new_ip_str);
-		}
-
-		return RC_OK;
-	}
-
 	return RC_DYNDNS_INVALID_RSP_FROM_IP_SERVER;
 }
 
@@ -549,7 +538,7 @@
 	 * That should be OK even if changes dyn_dns_update_ip to
 	 * iterate over servernum, but not if it's fix set to =! 0 */
 	if (p_self->info[0].my_ip_has_changed || p_self->force_addr_update ||
-	    (p_self->times_since_last_update > p_self->forced_update_times))
+	    p_self->times_since_last_update > p_self->forced_update_times)
 	{
 		for (i = 0; i < p_self->info_count; i++)
 		{
@@ -558,12 +547,12 @@
 			for (j = 0; j < info->alias_count; j++)
 			{
 				info->alias_info[j].update_required = TRUE;
-				logit(LOG_WARNING, MODULE_TAG "Update needed for alias %s, new IP# %s",
+               	if (p_self->dbg.level > 1)
+				  logit(LOG_WARNING, MODULE_TAG "Update needed for %s => %s",
 				      info->alias_info[j].names.name, info->my_ip_address.name);
 			}
 		}
-	}
-
+	}    	
 	return RC_OK;
 }
 
@@ -683,10 +672,9 @@
 
 		for (j = 0; j < info->alias_count; j++)
 		{
-			if (info->alias_info[j].update_required != TRUE)
-			{
+			int *updateDue = &info->alias_info[j].update_required;
+			if (!*updateDue)
 				continue;
-			}
 
 			rc = http_client_init(&p_self->http_to_dyndns[i], "Sending IP# update to DDNS server");
 			if (rc != RC_OK)
@@ -709,8 +697,7 @@
 			if (p_self->dbg.level > 2)
 			{
 				p_self->p_req_buffer[http_tr.req_len] = 0;
-				logit(LOG_DEBUG, MODULE_TAG "Sending alias table update to DDNS server:");
-				logit(LOG_DEBUG, MODULE_TAG "%s", p_self->p_req_buffer);
+				logit(LOG_DEBUG, MODULE_TAG "Updating DDNS server => %s", p_self->p_req_buffer);
 			}
 
 			if (rc == RC_OK)
@@ -721,9 +708,9 @@
 										    info->p_dns_system->p_success_string);
 				if (update_ok)
 				{
-					info->alias_info[j].update_required = FALSE;
+					*updateDue = FALSE;
 
-					logit(LOG_INFO, MODULE_TAG "Successful alias table update for %s => new IP# %s",
+					logit(LOG_WARNING, MODULE_TAG "Updated %s => %s",
 					      info->alias_info[j].names.name, info->my_ip_address.name);
 					p_self->times_since_last_update = 0;
 				}
@@ -735,14 +722,6 @@
 					logit(LOG_WARNING, MODULE_TAG "%s", http_tr.p_rsp);
 					rc = RC_DYNDNS_RSP_NOTOK;
 				}
-
-				if (p_self->dbg.level > 2 || !update_ok)
-				{
-					http_tr.p_rsp[http_tr.rsp_len] = 0;
-					logit(LOG_DEBUG, MODULE_TAG "Updating alias table, DDNS server response:");
-					logit(LOG_DEBUG, MODULE_TAG "%s", http_tr.p_rsp);
-				}
-
 				anychange += update_ok; /* Adjust forced update period on success */
 			}
 
@@ -762,20 +741,21 @@
 	}
 
 	/* Successful change or when cache file does not yet exist! */
-	if (anychange || access(DYNDNS_DEFAULT_CACHE_FILE, F_OK))
+	if (anychange || p_self->cachefile)
 	{
-		FILE *fp;
+		if (p_self->cachefile) {
+            FILE *fp;
 
-		/* Update cache with new IP */
-		fp = fopen(DYNDNS_DEFAULT_CACHE_FILE, "w");
-		if (fp)
-		{
-			fprintf(fp, "%s", p_self->info[0].my_ip_address.name);
-			fclose(fp);
+		    /* Update cache with new IP */
+		    fp = fopen(p_self->cachefile, "w");
+		    if (fp) {
+			    fprintf(fp, "%s", p_self->info[0].my_ip_address.name);
+			    fclose(fp);
+		    }else if (p_self->dbg.level > 0)
+                logit(LOG_WARNING, MODULE_TAG "Could not update %s: %s",
+                      p_self->cachefile, strerror(errno));
 		}
-
-		if (anychange)
-		{
+		if (anychange) {
 			/* Recalculate forced update period */
 			p_self->forced_update_times = p_self->forced_update_period_sec / p_self->sleep_sec;
 
@@ -812,9 +792,6 @@
 
 		/* Domain wildcarding disabled by default */
 		p_self->wildcard = FALSE;
-
-		/* pidfile */
-		p_self->pidfile = strdup(DYNDNS_DEFAULT_PIDFILE);
 	}
 	while (0);
 
@@ -879,7 +856,7 @@
 
 void dyn_dns_print_hello(void)
 {
-	logit(LOG_INFO, "%s", DYNDNS_VERSION_STRING);
+	logit(LOG_WARNING, "%s", DYNDNS_VERSION_STRING);
 }
 
 /**
@@ -951,10 +928,11 @@
 		}
 		http_to_dyndns_constructed = TRUE;
 
-		(p_self)->cmd = NO_CMD;
-		(p_self)->sleep_sec = DYNDNS_DEFAULT_SLEEP;
-		(p_self)->total_iterations = DYNDNS_DEFAULT_ITERATIONS;
-		(p_self)->initialized = FALSE;
+		p_self->cmd = NO_CMD;
+		p_self->sleep_sec = DYNDNS_DEFAULT_SLEEP;
+		p_self->total_iterations = DYNDNS_DEFAULT_ITERATIONS;
+        p_self->check_ip_period_sec = 1;  /* always */
+		p_self->initialized = FALSE;
 
 		i = 0;
 		while (i < DYNDNS_MAX_SERVER_NUMBER)
@@ -1005,11 +983,6 @@
 		return RC_OK;
 	}
 
-	if (p_self->initialized == TRUE)
-	{
-		dyn_dns_shutdown(p_self);
-	}
-
 	rc = http_client_destruct(p_self->http_to_ip_server, DYNDNS_MAX_SERVER_NUMBER);
 	if (rc != RC_OK)
 	{
@@ -1077,7 +1050,6 @@
 		return RC_OK;
 	}
 
-	p_self->abort_on_network_errors = FALSE;
 	p_self->force_addr_update = FALSE;
 
 	do
@@ -1121,24 +1093,124 @@
 	return RC_OK;
 }
 
-/**
-   Disconnect and some other clean up.
+
+/*
+  Strip trailing whitespace
 */
-RC_TYPE dyn_dns_shutdown(DYN_DNS_CLIENT *p_self)
+static void chomp(char *s)
 {
-	if (p_self == NULL)
-	{
-		return RC_INVALID_POINTER;
-	}
+  char *end = s+strlen(s);
+  while (end > s && (unsigned)end[-1] <= ' ')
+    --end;
+  *end = 0;
+}
 
-	if (p_self->initialized == FALSE)
-	{
+
+/** get public IP address by scanning listed network interfaces
+	return RC_OK only if one of the listed interfaces is up and
+    has an IP address associated with it
+*/
+RC_TYPE getIPfromIfaces(DYN_DNS_CLIENT *p_self)
+{
+  ifaceList *lastIface = p_self->lastIface;
+  ifaceList *iface = lastIface;
+  if (iface) {
+    struct in_addr ip;
+    do {
+      iface = iface->next;
+      char *ifname = iface->name;
+      const char *tic = "";
+      /* iface names that start with backtic are actually shell scripts */
+      if (*ifname == '`') {
+        FILE *pipe = os_pipe_out(ifname+1);
+        char ipStr[32];
+        if (!pipe) {
+          logit(LOG_WARNING, MODULE_TAG "Could not execute %s`!", ifname);
+          continue;
+        } /* no short-circuit eval here -- pipe_close() must always be run! */
+        if ((!fgets(ipStr, sizeof ipStr, pipe)) | os_pipe_close(pipe)) {
+          if (p_self->dbg.level > 0)
+            logit(LOG_WARNING, MODULE_TAG "%s` failed!", ifname);
+          continue;
+        }
+        tic = "`";
+        chomp(ipStr);
+        if (!inet_aton(ipStr, &ip)) {
+          if (p_self->dbg.level > 3)
+            logit(LOG_WARNING, MODULE_TAG "%s` output invalid IP address '%s'",
+                  ifname, ipStr);
+          continue;
+        }          
+      }else{  /* ifname = local network interface */
+	    if (os_ifaceIP(ifname, &ip)) {
+		  if (p_self->dbg.level > 3)
+              logit(LOG_WARNING, MODULE_TAG "%s%s unavailable",ifname,tic);
+          continue;
+        }
+      }
+      {
+        char *publicIP = inet_ntoa(ip);
+        if (p_self->dbg.level > 1)
+			logit(LOG_NOTICE, MODULE_TAG "%s%s at %s",ifname,tic, publicIP);
+		setMyIP(p_self, publicIP);
 		return RC_OK;
-	}
+	  }
+    } while (iface != lastIface);
+    if (p_self->dbg.level > 2)
+      logit(LOG_WARNING, MODULE_TAG "no public interface(s) are up");
+  }
+  return RC_NET_INTERFACES_DOWN;
+}
 
-	return RC_OK;
+
+/***
+   Lookup our DNS aliases
+   Returns RC_DYNDNS_UNRESOLVED_ALIAS if one or more IPs did not agree
+   Other error codes indicate a networking failure
+*/
+static RC_TYPE dnslookup (DYN_DNS_CLIENT *p_self)
+{
+	char name[DYNDNS_SERVER_NAME_LENGTH];
+	struct addrinfo hints;
+	struct addrinfo *result;
+    int i;
+    RC_TYPE rc = RC_OK;
+
+	/* Clear DNS cache before querying for the IP below. */
+	res_init();
+
+	/* Try a DNS lookup of our last known IP#. */
+    DYNDNS_INFO_TYPE *info0=p_self->info;
+   	DYNDNS_INFO_TYPE *info=info0;       
+	for (i = 0; i < p_self->info_count; i++, info++)
+		if (info->alias_count) {
+			/* DNS Lookup */
+			memset(&hints, 0, sizeof(struct addrinfo));
+			hints.ai_family = AF_INET;      /* We want IPv4 */
+			hints.ai_socktype = SOCK_DGRAM; /* Datagram socket */
+			hints.ai_flags = 0;
+			hints.ai_protocol = 0;          /* Any protocol */
+
+			if (getaddrinfo(info->alias_info[0].names.name, NULL, &hints, &result))
+            	return RC_NET_INTERFACES_DOWN;
+			/* DNS reply for alias found, convert to IP# */
+			if (getnameinfo(result->ai_addr, result->ai_addrlen, name, sizeof(name), NULL, 0, NI_NUMERICHOST)) {
+            	freeaddrinfo(result);  /* would not be a networking error! */
+            	return RC_DYNDNS_UNRESOLVED_ALIAS;
+            }
+			/* Verify and update local record for next checkip call. */
+            if (strncmp(info->my_ip_address.name, name, DYNDNS_SERVER_NAME_LENGTH)) {
+				strncpy(info->my_ip_address.name, name, DYNDNS_SERVER_NAME_LENGTH);
+                rc = RC_DYNDNS_UNRESOLVED_ALIAS;
+            }
+            if (p_self->dbg.level)
+			  logit(LOG_INFO, MODULE_TAG "Resolved %s to %s", info->alias_info[0].names.name, name);
+			freeaddrinfo(result);
+		}
+    return rc;
 }
 
+
 /** the real action:
     - increment the forced update times counter
     - detect current IP
@@ -1152,60 +1224,60 @@
 RC_TYPE dyn_dns_update_ip(DYN_DNS_CLIENT *p_self)
 {
 	int servernum = 0; /* server to use for requesting IP */
-		     /*use server 0 by default, should be always exist */
+		     /*use server 0 by default, should always exist */
+    char *ipname = p_self->info[servernum].my_ip_address.name;
 	RC_TYPE rc;
 
 	if (p_self == NULL)
-	{
 		return RC_INVALID_POINTER;
-	}
 
-	do
-	{
-		/* Ask IP server something so he will respond and give me my IP */
+	if (p_self->check_ip_period_sec &&
+         (p_self->secs_since_last_check+=p_self->sleep_sec) >= 
+          p_self->check_ip_period_sec) {
+        if ((rc = getIPfromIfaces(p_self)) == RC_OK) {
+        	char publicIP[DYNDNS_SERVER_NAME_LENGTH];
+            strncpy(publicIP, ipname, DYNDNS_SERVER_NAME_LENGTH);
+            switch (rc=dnslookup(p_self)) {
+            	case RC_DYNDNS_UNRESOLVED_ALIAS:
+					setMyIP(p_self, publicIP);
+                 case RC_OK:
+        			p_self->secs_since_last_check = 0;       
+                	goto skipDDNSquery;
+                default:
+                	return rc;
+            }
+        }
+queryDDNS:
+	    /* probe IP server and parse response to get my IP */
 		rc = do_ip_server_transaction(p_self, servernum);
 		if (rc != RC_OK)
-		{
-			break;
-		}
-		if (p_self->dbg.level > 1)
-		{
-			logit(LOG_DEBUG, MODULE_TAG "DDNS server response:");
-			logit(LOG_DEBUG, MODULE_TAG "%s", p_self->p_work_buffer);
-		}
+			return rc;
+        p_self->secs_since_last_check = 0;       
+		if (p_self->dbg.level > 3)
+			logit(LOG_DEBUG, MODULE_TAG
+                	"DDNS server response: %s", p_self->p_work_buffer);
 
 		/* Extract our IP, check if different than previous one */
 		rc = do_parse_my_ip_address(p_self, servernum);
-		if (rc != RC_OK)
-		{
-			break;
-		}
-
-		if (p_self->dbg.level > 1)
-		{
-			logit(LOG_INFO, MODULE_TAG "Current public IP# %s", p_self->info[servernum].my_ip_address.name);
-		}
-
-		/* Step through aliases list, resolve them and check if they point to my IP */
-		rc = do_check_alias_update_table(p_self);
-		if (rc != RC_OK)
-		{
-			break;
-		}
+	}else /* extract IP address from any of our available "public" interfaces */
+        rc = getIPfromIfaces(p_self);
+	if (rc != RC_OK)
+        return rc;
+skipDDNSquery:
+	if (p_self->dbg.level)
+		logit(LOG_INFO, MODULE_TAG "Current public IP# %s", ipname);
 
-		/* Update IPs marked as not identical with my IP */
-		rc = do_update_alias_table(p_self);
-		if (rc != RC_OK)
-		{
-			break;
-		}
-	}
-	while (0);
+	/* Step through aliases list, resolve them and check if they point to my IP */
+	rc = do_check_alias_update_table(p_self);
+	if (rc != RC_OK)
+		return rc;
 
-	return rc;
+	/* Update IPs marked as not identical with my IP */
+	return do_update_alias_table(p_self);
 }
 
 
+
 /** MAIN - Dyn DNS update entry point
     Actions:
     - read the configuration options
@@ -1218,16 +1290,12 @@
 	FILE *fp;
 	RC_TYPE rc = RC_OK;
 	int i;
-	char name[DYNDNS_SERVER_NAME_LENGTH];
 
 	if (p_dyndns == NULL)
 	{
 		return RC_INVALID_POINTER;
 	}
 
-	/* Create pid and cache file repository. */
-	mkdir(DYNDNS_RUNTIME_DATA_DIR, 0755);
-
 	/* read cmd line options and set object properties */
 	rc = get_config_data(p_dyndns, argc, argv);
 	if (rc != RC_OK || p_dyndns->abort)
@@ -1289,15 +1357,14 @@
 	umask(S_IWGRP | S_IWOTH);
 
 	/* write pid file */
-	fp = fopen(p_dyndns->pidfile, "w");
-	if (!fp)
-	{
-		logit(LOG_ERR, MODULE_TAG "Failed opening pidfile %s for writing: %s", p_dyndns->pidfile, strerror(errno));
-		return RC_ERROR;
+    if (p_dyndns->pidfile) {
+	    if ((fp = fopen(p_dyndns->pidfile, "w"))) {
+        	fprintf(fp, "%u", getpid());
+			fclose(fp);
+        }else
+		    logit(LOG_ERR, MODULE_TAG "Could not write pidfile %s: %s", 
+            		p_dyndns->pidfile, strerror(errno));
 	}
-	fprintf(fp, "%u", getpid());
-	fclose(fp);
-
 	dyn_dns_print_hello();
 
 	/* At boot, or when restarting inadyn at runtime, the memory struct holding
@@ -1305,43 +1372,9 @@
 	 * DDNS server record, since we might get locked out for abuse, so we "seed"
 	 * each of the DDNS records of our struct with the cached IP# from our cache
 	 * file, or from a regular DNS query. */
-	fp = fopen(DYNDNS_DEFAULT_CACHE_FILE, "r");
-	if (!fp)
-	{
-		struct addrinfo hints;
-		struct addrinfo *result;
-
-		/* Clear DNS cache before querying for the IP below. */
-		res_init();
-
-		/* Try a DNS lookup of our last known IP#. */
-		for (i = 0; i < p_dyndns->info_count; i++)
-		{
-			if (p_dyndns->info[i].alias_count)
-			{
-				/* DNS Lookup */
-				memset(&hints, 0, sizeof(struct addrinfo));
-				hints.ai_family = AF_UNSPEC;    /* Allow IPv4 or IPv6 */
-				hints.ai_socktype = SOCK_DGRAM; /* Datagram socket */
-				hints.ai_flags = 0;
-				hints.ai_protocol = 0;          /* Any protocol */
-
-				if (!getaddrinfo(p_dyndns->info[i].alias_info[0].names.name, NULL, &hints, &result))
-				{
-					/* DNS reply for alias found, convert to IP# */
-					if (!getnameinfo(result->ai_addr, result->ai_addrlen, name, sizeof(name), NULL, 0, NI_NUMERICHOST))
-					{
-						/* Update local record for next checkip call. */
-						strncpy(p_dyndns->info[i].my_ip_address.name, name, sizeof(p_dyndns->info[i].my_ip_address.name));
-						logit(LOG_INFO, MODULE_TAG "Resolving hostname %s => IP# %s", p_dyndns->info[i].alias_info[0].names.name, name);
-					}
-					freeaddrinfo(result);
-				}
-			}
-		}
-	}
-	else
-	{
+	
+	if (p_dyndns->cachefile && (fp = fopen(p_dyndns->cachefile, "r"))) {
+		char name[DYNDNS_SERVER_NAME_LENGTH];
 		/* Read cached IP# from inadyn cache file. */
 		if (fgets(name, sizeof(name), fp))
 		{
@@ -1353,8 +1386,9 @@
 				strncpy(p_dyndns->info[i].my_ip_address.name, name, sizeof(p_dyndns->info[i].my_ip_address.name));
 			}
 		}
-		fclose(fp);
-	}
+		fclose(fp);        
+	}else    
+    	dnslookup(p_dyndns);  /* seed from DNS in absence of local cache, ignore errors */
 
 	do
 	{
@@ -1406,40 +1440,31 @@
 				/* dyn_dns_update_ip() failed above, and we've not reached MAX iterations. 
 				 * Time to inform the user the (network) error is not fatal and that we
 				 * will try again in a short while. */
-				logit(LOG_WARNING, MODULE_TAG "Will retry again in %d sec...", p_dyndns->sleep_sec);
+				if (p_dyndns->onNetErr) {
+                	logit(LOG_WARNING, MODULE_TAG "Running %s -- retrying in %d sec...", 
+							p_dyndns->onNetErr, p_dyndns->sleep_sec);
+					if (os_shell_execute(p_dyndns->onNetErr))
+						logit(LOG_ERR, MODULE_TAG "%s failed!", p_dyndns->onNetErr);                   
+				}else
+                	logit(LOG_WARNING, MODULE_TAG "Will retry in %d sec...", p_dyndns->sleep_sec);
 			}
 
 			/* Now sleep a while. Using the time set in sleep_sec data member */
 			dyn_dns_wait_for_cmd(p_dyndns);
 			if (p_dyndns->cmd == CMD_STOP)
 			{
-				logit(LOG_DEBUG, MODULE_TAG "STOP command received, exiting.");
-				rc = RC_OK;
+				rc = RC_STOP;
 				break;
 			}
 			else if (p_dyndns->cmd == CMD_RESTART)
 			{
-				logit(LOG_DEBUG, "RESTART command received, restarting.");
 				rc = RC_RESTART;
 				break;
 			}
-
-			if (p_dyndns->dbg.level > 0)
-			{
-				logit(LOG_DEBUG, ".");
-//				logit(LOG_DEBUG, "Time since last update: (%d) %d", p_dyndns->times_since_last_update, p_dyndns->times_since_last_update * p_dyndns->sleep_sec);
-			}
 			p_dyndns->times_since_last_update ++;
 		}
 	}
 	while (0);
-
-	/* if everything ok here we should exit. End of program */
-	if (rc == RC_OK)
-	{
-	    rc = dyn_dns_shutdown(p_dyndns);
-	}
-
 	return rc;
 }
 
diff -ru inadyn-1.98.1/src/errorcode.c inadyn-mbari7/src/errorcode.c
--- inadyn-1.98.1/src/errorcode.c	2011-07-18 06:05:26.000000000 -0700
+++ inadyn-mbari7/src/errorcode.c	2013-03-02 17:24:55.522180629 -0800
@@ -41,7 +41,8 @@
 	{RC_IP_RECV_ERROR,			"RC_IP_RECV_ERROR"},
 	{RC_IP_OBJECT_NOT_INITIALIZED,		"RC_IP_OBJECT_NOT_INITIALIZED"},
 	{RC_IP_OS_SOCKET_INIT_FAILED,		"RC_IP_OS_SOCKET_INIT_FAILED"},
-	
+    {RC_IP_SOCKET_BIND_ERROR,			"RC_IP_SOCKET_BIND_ERROR"},
+	{RC_NET_INTERFACES_DOWN,			"RC_NET_INTERFACES_DOWN"},	
 	{RC_TCP_OBJECT_NOT_INITIALIZED,		"RC_TCP_OBJECT_NOT_INITIALIZED"},
 
 	{RC_HTTP_OBJECT_NOT_INITIALIZED,	"RC_HTTP_OBJECT_NOT_INITIALIZED"},
diff -ru inadyn-1.98.1/src/inadyn_cmd.c inadyn-mbari7/src/inadyn_cmd.c
--- inadyn-1.98.1/src/inadyn_cmd.c	2011-07-18 06:05:26.000000000 -0700
+++ inadyn-mbari7/src/inadyn_cmd.c	2013-03-02 17:24:55.526180669 -0800
@@ -42,6 +42,7 @@
 static RC_TYPE get_username_handler(CMD_DATA *p_cmd, int current_nr, void *p_context);
 static RC_TYPE get_password_handler(CMD_DATA *p_cmd, int current_nr, void *p_context);
 static RC_TYPE get_alias_handler(CMD_DATA *p_cmd, int current_nr, void *p_context);
+static RC_TYPE add_iface_handler(CMD_DATA *p_cmd, int current_nr, void *p_context);
 static RC_TYPE get_dns_server_name_handler(CMD_DATA *p_cmd, int current_nr, void *p_context);
 static RC_TYPE get_dns_server_url_handler(CMD_DATA *p_cmd, int current_nr, void *p_context);
 static RC_TYPE get_ip_server_name_handler(CMD_DATA *p_cmd, int current_nr, void *p_context);
@@ -49,7 +50,9 @@
 static RC_TYPE get_update_period_handler(CMD_DATA *p_cmd, int current_nr, void *p_context);
 static RC_TYPE get_update_period_sec_handler(CMD_DATA *p_cmd, int current_nr, void *p_context);
 static RC_TYPE get_forced_update_period_handler(CMD_DATA *p_cmd, int current_nr, void *p_context);
+static RC_TYPE get_check_ip_period_handler(CMD_DATA *p_cmd, int current_nr, void *p_context);
 static RC_TYPE get_logfile_name(CMD_DATA *p_cmd, int current_nr, void *p_context);
+static RC_TYPE set_restart_handler(CMD_DATA *p_cmd, int current_nr, void *p_context);
 static RC_TYPE set_silent_handler(CMD_DATA *p_cmd, int current_nr, void *p_context);
 static RC_TYPE set_verbose_handler(CMD_DATA *p_cmd, int current_nr, void *p_context);
 static RC_TYPE get_proxy_server_handler(CMD_DATA *p_cmd, int current_nr, void *p_context);
@@ -59,8 +62,10 @@
 static RC_TYPE set_change_persona_handler(CMD_DATA *p_cmd, int current_nr, void *p_context);
 static RC_TYPE set_bind_interface(CMD_DATA *p_cmd, int current_nr, void *p_context);
 static RC_TYPE set_pidfile(CMD_DATA *p_cmd, int current_nr, void *p_context);
+static RC_TYPE set_cachefile(CMD_DATA *p_cmd, int current_nr, void *p_context);
 static RC_TYPE print_version_handler(CMD_DATA *p_cmd, int current_nr, void *p_context);
 static RC_TYPE get_exec_handler(CMD_DATA *p_cmd, int current_nr, void *p_context);
+static RC_TYPE get_err_handler(CMD_DATA *p_cmd, int current_nr, void *p_context);
 
 static CMD_DESCRIPTION_TYPE cmd_options_table[] =
 {
@@ -71,6 +76,15 @@
 	{"-b",			0,	{set_silent_handler, NULL},	""},
 	{"--background",	0,	{set_silent_handler, NULL},	"Run in background."},
 
+	{"-C",			1,	{set_cachefile, NULL}, ""},
+	{"--cache",		1,	{set_cachefile, NULL}, "<FILE>\n"
+	 "\t\t\tSet IP address cache file, default none."},
+
+	{"-c",          1,   {get_check_ip_period_handler, NULL}, ""},
+	{"--check",		1,   {get_check_ip_period_handler, NULL}, "<SEC>\n\t\t\t"
+	 "How often to check IP address against DDNS server.\n\t\t\t"
+     "Default: 1 --> always,  Note: 0 --> never"},
+
 	{"-d",			1,	{set_change_persona_handler, NULL}, ""},
 	{"--drop-privs", 	1,	{set_change_persona_handler, NULL}, "<USER[:GROUP]>\n"
 	 "\t\t\tAfter init switch to a new user/group.\n"
@@ -80,11 +94,16 @@
 	{"-e",			1,	{get_exec_handler, NULL}, ""},
 	{"--exec",		1,	{get_exec_handler, NULL}, "Full path to external command to run after an IP update."},
 
+	{"-n",			1,	{get_err_handler, NULL}, ""},
+	{"--on_net_err",1,	{get_err_handler, NULL}, 
+      "External shell command to run after a network error"},
+
 	{"-f",			   1,   {get_forced_update_period_handler, NULL}, ""},
-	{"--forced-update",        1,   {get_forced_update_period_handler, NULL}, "<SEC>\n"
+	{"--forced-update",1,   {get_forced_update_period_handler, NULL}, "<SEC>\n"
 	 "\t\t\tForced DDNS server update interval. Default: 1 week"},
 	{"--forced_update_period", 1,   {get_forced_update_period_handler, NULL}, NULL}, /* COMPAT */
 
+
 	{"-F",				1, {get_options_from_file_handler, NULL}, ""},
 	{"--config",			1, {get_options_from_file_handler, NULL}, "<FILE>\n"
 	 "\t\t\tConfiguration file, containing further options.  Default\n"
@@ -104,6 +123,14 @@
 	{"--iterations",	1,	{set_iterations_handler, NULL},	"<NUM>\n"
 	 "\t\t\tSet the number of DNS updates. Default: 0 (forever)"},
 
+	{"-I",        1,    {add_iface_handler, NULL},  "" },    
+	{"--public",  1,    {add_iface_handler, NULL},  "<IFNAME> or `shell cmd`\n\t\t\t"
+    	"Name of network interface at our public IP address.\n\t\t\t"
+        "If argument enclosed in `backquotes`, it is interpreted\n\t\t\t"
+        "as a shell command, whose stdout is in dotted quad form.\n\t\t\t"
+        "If multiple specified, the first listed that\n\t\t\t"
+        "returns a valid address is used.  Unix Only."},
+
 	{"-i",			1,	{set_bind_interface, NULL}, ""},
 	{"--iface",		1,	{set_bind_interface, NULL}, "<IFNAME>\n"
 	 "\t\t\tSet interface to bind to, only on UNIX systems."},
@@ -122,10 +149,13 @@
 	 "\t\t\tset the dyndns system.  Default servers will be taken."},
 	{"--dyndns_server_name", 1, {get_dns_server_name_handler, NULL}, NULL},
 
+	{"-r",			0,	{set_restart_handler, NULL},	""},
+	{"--restart",	0,	{set_restart_handler, NULL},	"Never exit."},
+
 	{"-U",		 	1, {get_dns_server_url_handler, NULL}, ""},
 	{"--server-url", 	1, {get_dns_server_url_handler, NULL}, "<URL>\n"
 	 "\t\t\tFull URL relative to DynDNS server root.\n"
-	 "\t\t\tEx: /some_script.php?hostname=\n"},
+	 "\t\t\tEx: /some_script.php?hostname="},
 	{"--dyndns_server_url", 1, {get_dns_server_url_handler, NULL}, NULL},
 
 	{"-S",			1,	{get_dyndns_system_handler, NULL}, ""},
@@ -144,8 +174,7 @@
 	 "\t\t\to For tunnelbroker.net:   ipv6tb@he.net\n"
 	 "\t\t\to For dynsip.org:         default@dynsip.org\n"
 	 "\t\t\to For sitelutions.com:    default@sitelutions.com\n"
-	 "\t\t\to For generic:            custom@http_svr_basic_auth\n\n"
-	 "\t\t\tDefault value:            dyndns@dyndns.org"},
+	 "\t\t\to For generic:            custom@http_svr_basic_auth"},
 	{"--dyndns_system",	1,	{get_dyndns_system_handler, NULL}, NULL},
 
 	{"-x",			1,	{get_proxy_server_handler, NULL}, ""},
@@ -165,7 +194,7 @@
 
 	{"-s",			0,	{set_syslog_handler, NULL}, ""},
 	{"--syslog",		0,	{set_syslog_handler, NULL},
-	 "Force logging to syslog, e.g., /var/log/messages, only on UNIX systems"},
+	 "Force logging to syslog, only on UNIX systems"},
 
 	{"-u",			1,	{get_username_handler, NULL},	""},
 	{"--username",		1,	{get_username_handler, NULL},	"<USERNAME>\n"
@@ -176,7 +205,8 @@
 	 "\t\t\tYour DDNS user password."},
 
 	{"-w",			0,	{wildcard_handler, NULL}, ""},
-	{"--wildcard",		0,	{wildcard_handler, NULL}, "Enable domain wildcarding for dyndns.org, 3322.org, or easydns.com."},
+	{"--wildcard",		0,	{wildcard_handler, NULL}, "Enable domain wildcarding\n\t\t\t"
+                            "for dyndns.org, 3322.org, or easydns.com."},
 
 	{"-h",			0,	{help_handler, NULL},	"" },
 	{"--help",		0,	{help_handler, NULL},	"This online help." },
@@ -305,6 +335,22 @@
 	return RC_OK;
 }
 
+static RC_TYPE set_restart_handler(CMD_DATA *p_cmd, int current_nr, void *p_context)
+{
+	DYN_DNS_CLIENT *p_self = (DYN_DNS_CLIENT *)p_context;
+
+	(void)p_cmd;
+	(void)current_nr;
+
+	if (p_self == NULL)
+	{
+		return RC_INVALID_POINTER;
+	}
+
+	p_self->restart = TRUE;
+	return RC_OK;
+}
+
 static RC_TYPE get_logfile_name(CMD_DATA *p_cmd, int current_nr, void *p_context)
 {
 	DYN_DNS_CLIENT *p_self = (DYN_DNS_CLIENT *) p_context;
@@ -403,6 +449,43 @@
 	return RC_OK;
 }
 
+
+/**
+    Parses local network interface from which to get public IP address
+    Example: eth0
+    Action:  appends interface to list of those net interface to check for an ip
+            The first listed interface with a valid IP is assumed to be
+             the machine's external address.  Only if no listed interfaces
+             have an IP address do we resort to checking our IP via an http probe
+*/
+static RC_TYPE add_iface_handler(CMD_DATA *p_cmd,int current_nr,void *p_context)
+{
+  DYN_DNS_CLIENT *p_self = (DYN_DNS_CLIENT *) p_context;
+  char *arg = p_cmd->argv[current_nr];
+  ifaceList *iface;
+
+  if (p_self == NULL)
+  {
+      return RC_INVALID_POINTER;
+  }
+  iface = malloc(sizeof(ifaceList));
+  if (!iface)
+    return RC_OUT_OF_MEMORY;
+  if (*arg == '`' && arg[strlen(arg)-1] == '`')
+    arg[strlen(arg)-1] = 0;  /* delete trailing backtic */
+  iface->name = strdup(arg);
+  if (!iface->name)
+    return RC_OUT_OF_MEMORY;  
+  if (p_self->lastIface) {
+    iface->next = p_self->lastIface->next;    
+    p_self->lastIface->next = iface;
+  }else
+    iface->next = iface;  
+  p_self->lastIface = iface;
+  return RC_OK;
+}
+
+
 static RC_TYPE get_name_and_port(char *p_src, char *p_dest_name, int *p_dest_port)
 {
 	const char *p_port = NULL;
@@ -573,6 +656,22 @@
 	return RC_OK;
 }
 
+static RC_TYPE get_check_ip_period_handler(CMD_DATA *p_cmd, int current_nr, void *p_context)
+{
+	DYN_DNS_CLIENT *p_self = (DYN_DNS_CLIENT *) p_context;
+	if (p_self == NULL)
+	{
+		return RC_INVALID_POINTER;
+	}
+
+	if (sscanf(p_cmd->argv[current_nr], "%d", &p_self->check_ip_period_sec) != 1)
+	{
+		return RC_DYNDNS_INVALID_OPTION;
+	}
+
+	return RC_OK;
+}
+
 static RC_TYPE get_forced_update_period_handler(CMD_DATA *p_cmd, int current_nr, void *p_context)
 {
 	DYN_DNS_CLIENT *p_self = (DYN_DNS_CLIENT *) p_context;
@@ -776,6 +875,20 @@
 	return RC_OK;
 }
 
+static RC_TYPE set_cachefile(CMD_DATA *p_cmd, int current_nr, void *p_context)
+{
+	DYN_DNS_CLIENT *p_self = (DYN_DNS_CLIENT *)p_context;
+
+	if (p_self == NULL)
+	{
+		return RC_INVALID_POINTER;
+	}
+
+	p_self->cachefile = strdup(p_cmd->argv[current_nr]);
+
+	return RC_OK;
+}
+
 RC_TYPE print_version_handler(CMD_DATA *p_cmd, int current_nr, void *p_context)
 {
 	DYN_DNS_CLIENT *p_self = (DYN_DNS_CLIENT *)p_context;
@@ -794,6 +907,23 @@
 	return RC_OK;
 }
 
+
+static char *stripBackTics (char *cmd)
+{
+    if (*cmd == '`') { /* strip any backtic quotes */
+      cmd++;
+      char *last = cmd+strlen(cmd)-1;
+      if (*last == '`')
+        *last = 0;
+    }
+    cmd = strdup(cmd);
+    if (!cmd) {
+      fputs("Memory exhausted while parsing arguments!\n", stderr);
+      exit(10);
+    }
+    return cmd;
+}
+
 static RC_TYPE get_exec_handler(CMD_DATA *p_cmd, int current_nr, void *p_context)
 {
 	DYN_DNS_CLIENT *p_self = (DYN_DNS_CLIENT *)p_context;
@@ -805,9 +935,23 @@
 	{
 		return RC_INVALID_POINTER;
 	}
+    p_self->external_command = stripBackTics(p_cmd->argv[current_nr]);
+	return RC_OK;
+}
+
 
-	p_self->external_command = strdup(p_cmd->argv[current_nr]);
+static RC_TYPE get_err_handler(CMD_DATA *p_cmd, int current_nr, void *p_context)
+{
+	DYN_DNS_CLIENT *p_self = (DYN_DNS_CLIENT *)p_context;
+
+	(void)p_cmd;
+	(void)current_nr;
 
+	if (p_self == NULL)
+	{
+		return RC_INVALID_POINTER;
+	}
+	p_self->onNetErr = stripBackTics(p_cmd->argv[current_nr]);
 	return RC_OK;
 }
 
@@ -879,7 +1023,9 @@
 	COMMENT,
 	DATA,
 	SPACE,
-	ESCAPE
+	ESCAPE,
+    BACKTIC,
+    TICESC
 } PARSER_STATE;
 
 typedef struct
@@ -908,9 +1054,11 @@
     * States:
     * NEW_LINE - wait here until some option. Add '--' if not already there
     * SPACE - between options. Like NEW_LINE but no additions
-    * DATA - real data. Stop on space.
+    * DATA - real data ended by a space
+    * BACKTIC - quoted `argument` (typically a shell script)
     * COMMENT - everything beginning with # until EOLine
     * ESCAPE - everything that is otherwise (incl. spaces). Next char is raw copied.
+    * ESCTIC - ESCAPE within a BACKTIC quoted argument
     */
 static RC_TYPE parser_read_option(OPTION_FILE_PARSER *p_cfg, char *p_buffer, int maxlen)
 {
@@ -989,7 +1137,7 @@
 					{
 						break;
 					}
-					p_cfg->state = DATA;
+					p_cfg->state = ch == '`' ? BACKTIC : DATA;  /* start quoted argument */
 					break;
 				}
 				break;
@@ -1026,17 +1174,37 @@
 					break;
 				}
 				/*actual data*/
+				rc = push_in_buffer(&ch, 1, p_buffer, &count, maxlen);
+				break;
+
+			case ESCAPE:
 				if ((rc = push_in_buffer(&ch, 1, p_buffer, &count, maxlen)) != RC_OK)
 				{
 					break;
 				}
+				p_cfg->state = DATA;
 				break;
-			case ESCAPE:
+
+            case BACKTIC:  /* actual data until closing back quote */
+				if (ch == '\\')
+				{
+					p_cfg->state = TICESC;
+					break;
+				}
+                if ((rc = push_in_buffer(&ch, 1, p_buffer, &count, maxlen)) != RC_OK)
+				{
+					break;
+				}
+                if (ch == '`')
+					p_cfg->state = DATA;
+                break;
+
+			case TICESC:
 				if ((rc = push_in_buffer(&ch, 1, p_buffer, &count, maxlen)) != RC_OK)
 				{
 					break;
 				}
-				p_cfg->state = DATA;
+				p_cfg->state = BACKTIC;
 				break;
 
 			default:
diff -ru inadyn-1.98.1/src/main.c inadyn-mbari7/src/main.c
--- inadyn-1.98.1/src/main.c	2011-07-18 06:05:26.000000000 -0700
+++ inadyn-mbari7/src/main.c	2013-03-02 17:24:55.526180669 -0800
@@ -27,56 +27,37 @@
 /* MAIN - Dyn DNS update entry point.*/
 int inadyn_main(int argc, char* argv[])
 {
-	int restart = 0;
 	BOOL os_handler_installed = FALSE;
 	RC_TYPE rc = RC_OK;
 	DYN_DNS_CLIENT *p_dyndns = NULL;
 
-	do
-	{
+	do {    
 		/* create DYN_DNS_CLIENT object	*/
 		rc = dyn_dns_construct(&p_dyndns);
 		if (rc != RC_OK)
-		{
 			break;
-		}
 
 		/* install signal handler */
-		if (!os_handler_installed)
-		{
+		if (!os_handler_installed) {
 			rc = os_install_signal_handler(p_dyndns);
-			if (rc != RC_OK)
-			{
+			if (rc != RC_OK) {
 				logit(LOG_WARNING, MODULE_TAG  "Failed installing OS signal handler: %s", errorcode_get_name(rc));
 				break;
 			}
 			os_handler_installed = TRUE;
 		}
-
 		rc = dyn_dns_main(p_dyndns, argc, argv);
-		if (rc == RC_RESTART)
-		{
-			restart = 1;
-
-			/* do some cleanup if restart requested */
-			rc = dyn_dns_destruct(p_dyndns);
-			if (rc != RC_OK)
-			{
-				logit(LOG_WARNING, MODULE_TAG "Failed cleaning up before restart: %s, ignoring...", errorcode_get_name(rc));
-			}
-		}
-		else
-		{
-			/* Error, or OK.  In either case exit outer loop. */
-			restart = 0;
-		}
-	}
-	while (restart);
+		if (rc != RC_RESTART && (!p_dyndns->restart || rc == RC_STOP))
+			break;
+        
+		/* do some cleanup if restart requested */
+		rc = dyn_dns_destruct(p_dyndns);
+		if (rc != RC_OK)
+			logit(LOG_ERR, MODULE_TAG "Failed cleaning up before restart: %s, ignoring...", errorcode_get_name(rc));
+	} while (1);
 
-	if (rc != RC_OK)
-	{
-		logit(LOG_WARNING, MODULE_TAG "Failed %sstarting daemon: %s", restart ? "re" : "", errorcode_get_name(rc));
-	}
+    if (p_dyndns->pidfile)
+    	unlink(p_dyndns->pidfile);
 
 	/* Cleanup */
 	dyn_dns_destruct(p_dyndns);
diff -ru inadyn-1.98.1/src/os_unix.c inadyn-mbari7/src/os_unix.c
--- inadyn-1.98.1/src/os_unix.c	2011-07-18 06:05:26.000000000 -0700
+++ inadyn-mbari7/src/os_unix.c	2013-03-02 17:24:55.526180669 -0800
@@ -15,17 +15,19 @@
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA  02111-1307, USA.
- */
+*/
 
 #define MODULE_TAG ""
 #include "debug_if.h"
-
+  
 #include "os.h"
 #include "dyndns.h"
 
 #ifdef UNIX_OS
 #include <unistd.h>
 #include <sys/stat.h>
+#include <sys/ioctl.h>
+#include <net/if.h>
 
 #include "debug_if.h"
 
@@ -51,28 +53,18 @@
 
 RC_TYPE os_shell_execute(char * p_cmd)
 {
-	RC_TYPE rc = RC_OK;
-	int child;
-
-	child = vfork();
-	switch (child)
+	switch (vfork())
 	{
 		case 0: /* child */
 			execl("/bin/sh", "sh", "-c", p_cmd, (char *) 0);
-			exit(1);
-			break;
-
 		case -1:
-			rc = RC_OS_FORK_FAILURE;
-			break;
-
-		default: /* parent */
-			break;
+			return RC_OS_FORK_FAILURE;
 	}
-
-	return rc;
+	return RC_OK;
 }
 
+
+
 /* storage for the parameter needed by the handler */
 static void *global_p_signal_handler_param = NULL;
 
@@ -86,21 +78,21 @@
  * Since printf() is one of the possible back-ends of logit(), and printf() is not one
  * of the safe syscalls to be used, according to POSIX signal(7). The calls are commented,
  * since they are most likely also only needed for debugging.
- */
+*/
 static void unix_signal_handler(int signo)
-{
-	DYN_DNS_CLIENT *p_self = (DYN_DNS_CLIENT *)global_p_signal_handler_param;
+{	
+	DYN_DNS_CLIENT *p_self = (DYN_DNS_CLIENT *) global_p_signal_handler_param;
 
 	if (p_self == NULL)
 	{
-//		logit(LOG_WARNING, MODULE_TAG "Signal %d received. But handler is not installed correctly.", signo);
+		logit(LOG_WARNING, MODULE_TAG "Signal %d received. But handler is not installed correctly.", signo);
 		return;
 	}
 
-	switch (signo)
+	switch(signo)
 	{
 		case SIGHUP:
-//			logit(LOG_DEBUG, MODULE_TAG "Signal %d received. Sending restart command.", signo);
+			logit(LOG_DEBUG, MODULE_TAG "Signal %d received. Sending restart command.", signo);
 			p_self->cmd = CMD_RESTART;
 			break;
 
@@ -108,43 +100,94 @@
 		case SIGQUIT:
 		case SIGALRM:
 		case SIGTERM:
-//			logit(LOG_DEBUG, MODULE_TAG "Signal %d received. Sending shutdown command.", signo);
-			p_self->cmd = CMD_STOP;
-			break;
-
+			logit(LOG_DEBUG, MODULE_TAG "Signal %d received. Sending shutdown command.", signo);
+			p_self->cmd = CMD_STOP;			
+		break;
+        
+        case SIGCHLD:
+			for(;;) {
+            	int status;
+			    pid_t pid = waitpid(-1, &status, WNOHANG);
+                if (pid <= 0)
+                	break;
+
+			    if (WIFEXITED(status)) {
+                	int exitCode = WEXITSTATUS(status);
+				   logit(exitCode ? LOG_WARNING : LOG_INFO, 
+                   		 MODULE_TAG "PID[%d] exited with status=%d", pid, exitCode);
+			    }else if (WIFSIGNALED(status))
+				   logit(LOG_WARNING, MODULE_TAG "PID[%d] killed by signal %d", pid, WTERMSIG(status));
+			}
+            break;
+	
 		default:
-//			logit(LOG_DEBUG, MODULE_TAG "Signal %d received, ignoring.", signo);
-			break;
+			logit(LOG_DEBUG, MODULE_TAG "Signal %d received, ignoring.", signo);
+		break;
 	}
 	return;
+} 
+
+
+static int openPipes;
+static struct sigaction newact;
+
+/**
+ * Execute command capturing output
+ *  returns opened file * for reading output
+ */
+FILE *os_pipe_out(char * p_cmd)
+{
+    FILE *outPipe = popen(p_cmd, "r");
+    if (outPipe) {
+      if (!openPipes)
+        signal(SIGCHLD, SIG_DFL);
+      openPipes++;
+    }
+    return outPipe;
 }
 
 /**
-	install handler for SIGALRM and HUP, INT, QUIT, TERM.
-	avoid receiving HUP, INT, QUIT during ALRM and TERM.
+ * Execute command capturing output
+ *   returns return code from command pipe
+ */
+RC_TYPE os_pipe_close(FILE *pipe)
+{
+    RC_TYPE stat = RC_FILE_IO_OPEN_ERROR;
+    if (openPipes > 0) {
+      stat = pclose(pipe) ? RC_OS_FORK_FAILURE : RC_OK;
+      if (!--openPipes)
+        sigaction(SIGCHLD, &newact, NULL);
+    }
+    return stat;
+}
 
+/**
+	install handler for SIGALRM and HUP, INT, QUIT, TERM and CHLD.
+	avoid receiving HUP, INT, QUIT, and TERM during ALRM.	
 */
 RC_TYPE os_install_signal_handler(void *p_dyndns)
 {
-	RC_TYPE rc;
-	struct sigaction    newact;
+    RC_TYPE rc;
+
 	newact.sa_handler = unix_signal_handler;
 	newact.sa_flags   = 0;
+    openPipes = 0;
 
-	rc = sigemptyset(&newact.sa_mask)            ||
-		sigaddset(&newact.sa_mask, SIGHUP)   ||
-		sigaddset(&newact.sa_mask, SIGINT)   ||
-		sigaddset(&newact.sa_mask, SIGQUIT)  ||
-		sigaddset(&newact.sa_mask, SIGTERM)  ||
-		sigaction(SIGALRM, &newact, NULL)    ||
-		sigemptyset(&newact.sa_mask)         ||
-		sigaddset(&newact.sa_mask, SIGALRM)  ||
-		sigaction(SIGHUP, &newact, NULL)     ||
-		sigaction(SIGINT, &newact, NULL)     ||
-		sigaction(SIGQUIT, &newact, NULL)    ||
-		sigaction(SIGTERM, &newact, NULL);
+	rc = sigemptyset(&newact.sa_mask)         ||
+	     sigaddset(&newact.sa_mask, SIGHUP)   ||
+	     sigaddset(&newact.sa_mask, SIGINT)   ||
+	     sigaddset(&newact.sa_mask, SIGQUIT)  ||
+		 sigaddset(&newact.sa_mask, SIGTERM)  ||
+         sigaction(SIGALRM, &newact, NULL)    ||
+         sigemptyset(&newact.sa_mask)         ||
+	     sigaddset(&newact.sa_mask, SIGALRM)  ||
+         sigaction(SIGHUP, &newact, NULL)     ||
+         sigaction(SIGINT, &newact, NULL)     ||
+		 sigaction(SIGQUIT, &newact, NULL)    ||
+		 sigaction(SIGTERM, &newact, NULL)	  ||
+         sigaction(SIGCHLD, &newact, NULL);
  	if (rc == RC_OK)
- 	{
+	{
 		global_p_signal_handler_param = p_dyndns;
 	}
 
@@ -152,48 +195,48 @@
 }
 
 /*
-    closes current console
+    closes current console 
 
   July 5th, 2004 - Krev
   ***
-  This function is used to close the console window to start the
+  This function is used to close the console window to start the 
   software as a service on Windows. On Unix, closing the console window
   isn't used for a daemon, but rather it forks. Modified this function
   to fork into a daemon mode under Unix-compatible systems.
-
+  
   Actions:
     - for child:
-	- close in and err console
-	- become session leader
-	- change working directory
-	- clear the file mode creation mask
-    - for parent
-	just exit
+        - close in and err console
+        - become session leader 
+        - change working directory 
+        - clear the file mode creation mask 
+    - for parent 
+        just exit
 */
 RC_TYPE close_console_window(void)
 {
     pid_t pid = fork();
-
-    if (pid < 0)
+    
+    if(pid < 0)
     {
-	return RC_OS_FORK_FAILURE;
+        return RC_OS_FORK_FAILURE;
     }
-
+    
     if (pid == 0)		/* child */
     {
-	fclose(stdin);
-	fclose(stderr);
-	setsid();
+        fclose(stdin);
+        fclose(stderr);
+        setsid();  
 	if (-1 == chdir("/"))
 	{
 		logit(LOG_WARNING, MODULE_TAG "Failed changing cwd to /: %s", strerror(errno));
 	}
-	umask(0);
+        umask(0);  
 
-	return RC_OK;
+        return RC_OK;
     }
 
-    exit(0);
+        exit(0);
 
     return RC_OK;		/* Never reached. */
 }
@@ -218,10 +261,9 @@
 
 RC_TYPE os_change_persona(OS_USER_INFO *p_usr_info)
 {
-	int rc;
-
+	int rc = 0;
 	do
-	{
+	{	 
 		if (p_usr_info->gid != getgid())
 		{
 			if ((rc = setgid(p_usr_info->gid)) != 0)
@@ -231,23 +273,48 @@
 		}
 
 		if (p_usr_info->uid != getuid())
-		{
+		{			
 			if ((rc = setuid(p_usr_info->uid)) != 0)
 			{
 				break;
-			}
+			}    	
 		}
 	}
 	while(0);
 
 	if (rc != 0)
-	{
+    {
 		logit(LOG_WARNING, MODULE_TAG "Failed dropping privileges: %s", strerror(errno));
 		return RC_OS_CHANGE_PERSONA_FAILURE;
 	}
 
 	return RC_OK;
 }
+
+/** fill in buffer ip with the address of the specified network interface
+*/
+RC_TYPE os_ifaceIP (const char *iface, struct in_addr *ip)
+{
+  RC_TYPE err = RC_ERROR;
+  if (!iface || strlen(iface)>IFNAMSIZ)
+    errno = EINVAL;
+  else{
+    struct ifreq ifr;
+    int fd = socket(AF_INET, SOCK_DGRAM, 0);
+    if (fd >= 0) {
+      /* I want to get an IPv4 IP address */
+      ifr.ifr_addr.sa_family = AF_INET;
+      strncpy(ifr.ifr_name, iface, IFNAMSIZ);
+      if (!ioctl(fd, SIOCGIFADDR, &ifr)) {
+        *ip = ((struct sockaddr_in *)&ifr.ifr_addr)->sin_addr;
+        err = RC_OK;
+      }
+    }
+    close(fd);
+  }
+  return err;
+}
+
 #endif
 
 /**
