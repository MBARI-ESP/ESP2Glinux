diff --exclude CVS --exclude .git -uNr linux-2.6.33/arch/arm/boot/compressed/lib1funcs.S linux-2.6.33.modified/arch/arm/boot/compressed/lib1funcs.S
--- linux-2.6.33/arch/arm/boot/compressed/lib1funcs.S	1969-12-31 16:00:00.000000000 -0800
+++ linux-2.6.33.modified/arch/arm/boot/compressed/lib1funcs.S	2012-10-01 21:34:11.702323433 -0700
@@ -0,0 +1,348 @@
+/*
+ * linux/arch/arm/lib/lib1funcs.S: Optimized ARM division routines
+ *
+ * Author: Nicolas Pitre <nico@fluxnic.net>
+ *   - contributed to gcc-3.4 on Sep 30, 2003
+ *   - adapted for the Linux kernel on Oct 2, 2003
+ */
+
+/* Copyright 1995, 1996, 1998, 1999, 2000, 2003 Free Software Foundation, Inc.
+
+This file is free software; you can redistribute it and/or modify it
+under the terms of the GNU General Public License as published by the
+Free Software Foundation; either version 2, or (at your option) any
+later version.
+
+In addition to the permissions in the GNU General Public License, the
+Free Software Foundation gives you unlimited permission to link the
+compiled version of this file into combinations with other programs,
+and to distribute those combinations without any restriction coming
+from the use of this file.  (The General Public License restrictions
+do apply in other respects; for example, they cover modification of
+the file, and distribution when not linked into a combine
+executable.)
+
+This file is distributed in the hope that it will be useful, but
+WITHOUT ANY WARRANTY; without even the implied warranty of
+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+General Public License for more details.
+
+You should have received a copy of the GNU General Public License
+along with this program; see the file COPYING.  If not, write to
+the Free Software Foundation, 59 Temple Place - Suite 330,
+Boston, MA 02111-1307, USA.  */
+
+
+#include <linux/linkage.h>
+#include <asm/assembler.h>
+
+
+.macro ARM_DIV_BODY dividend, divisor, result, curbit
+
+#if __LINUX_ARM_ARCH__ >= 5
+
+	clz	\curbit, \divisor
+	clz	\result, \dividend
+	sub	\result, \curbit, \result
+	mov	\curbit, #1
+	mov	\divisor, \divisor, lsl \result
+	mov	\curbit, \curbit, lsl \result
+	mov	\result, #0
+	
+#else
+
+	@ Initially shift the divisor left 3 bits if possible,
+	@ set curbit accordingly.  This allows for curbit to be located
+	@ at the left end of each 4 bit nibbles in the division loop
+	@ to save one loop in most cases.
+	tst	\divisor, #0xe0000000
+	moveq	\divisor, \divisor, lsl #3
+	moveq	\curbit, #8
+	movne	\curbit, #1
+
+	@ Unless the divisor is very big, shift it up in multiples of
+	@ four bits, since this is the amount of unwinding in the main
+	@ division loop.  Continue shifting until the divisor is 
+	@ larger than the dividend.
+1:	cmp	\divisor, #0x10000000
+	cmplo	\divisor, \dividend
+	movlo	\divisor, \divisor, lsl #4
+	movlo	\curbit, \curbit, lsl #4
+	blo	1b
+
+	@ For very big divisors, we must shift it a bit at a time, or
+	@ we will be in danger of overflowing.
+1:	cmp	\divisor, #0x80000000
+	cmplo	\divisor, \dividend
+	movlo	\divisor, \divisor, lsl #1
+	movlo	\curbit, \curbit, lsl #1
+	blo	1b
+
+	mov	\result, #0
+
+#endif
+
+	@ Division loop
+1:	cmp	\dividend, \divisor
+	subhs	\dividend, \dividend, \divisor
+	orrhs	\result,   \result,   \curbit
+	cmp	\dividend, \divisor,  lsr #1
+	subhs	\dividend, \dividend, \divisor, lsr #1
+	orrhs	\result,   \result,   \curbit,  lsr #1
+	cmp	\dividend, \divisor,  lsr #2
+	subhs	\dividend, \dividend, \divisor, lsr #2
+	orrhs	\result,   \result,   \curbit,  lsr #2
+	cmp	\dividend, \divisor,  lsr #3
+	subhs	\dividend, \dividend, \divisor, lsr #3
+	orrhs	\result,   \result,   \curbit,  lsr #3
+	cmp	\dividend, #0			@ Early termination?
+	movnes	\curbit,   \curbit,  lsr #4	@ No, any more bits to do?
+	movne	\divisor,  \divisor, lsr #4
+	bne	1b
+
+.endm
+
+
+.macro ARM_DIV2_ORDER divisor, order
+
+#if __LINUX_ARM_ARCH__ >= 5
+
+	clz	\order, \divisor
+	rsb	\order, \order, #31
+
+#else
+
+	cmp	\divisor, #(1 << 16)
+	movhs	\divisor, \divisor, lsr #16
+	movhs	\order, #16
+	movlo	\order, #0
+
+	cmp	\divisor, #(1 << 8)
+	movhs	\divisor, \divisor, lsr #8
+	addhs	\order, \order, #8
+
+	cmp	\divisor, #(1 << 4)
+	movhs	\divisor, \divisor, lsr #4
+	addhs	\order, \order, #4
+
+	cmp	\divisor, #(1 << 2)
+	addhi	\order, \order, #3
+	addls	\order, \order, \divisor, lsr #1
+
+#endif
+
+.endm
+
+
+.macro ARM_MOD_BODY dividend, divisor, order, spare
+
+#if __LINUX_ARM_ARCH__ >= 5
+
+	clz	\order, \divisor
+	clz	\spare, \dividend
+	sub	\order, \order, \spare
+	mov	\divisor, \divisor, lsl \order
+
+#else
+
+	mov	\order, #0
+
+	@ Unless the divisor is very big, shift it up in multiples of
+	@ four bits, since this is the amount of unwinding in the main
+	@ division loop.  Continue shifting until the divisor is 
+	@ larger than the dividend.
+1:	cmp	\divisor, #0x10000000
+	cmplo	\divisor, \dividend
+	movlo	\divisor, \divisor, lsl #4
+	addlo	\order, \order, #4
+	blo	1b
+
+	@ For very big divisors, we must shift it a bit at a time, or
+	@ we will be in danger of overflowing.
+1:	cmp	\divisor, #0x80000000
+	cmplo	\divisor, \dividend
+	movlo	\divisor, \divisor, lsl #1
+	addlo	\order, \order, #1
+	blo	1b
+
+#endif
+
+	@ Perform all needed substractions to keep only the reminder.
+	@ Do comparisons in batch of 4 first.
+	subs	\order, \order, #3		@ yes, 3 is intended here
+	blt	2f
+
+1:	cmp	\dividend, \divisor
+	subhs	\dividend, \dividend, \divisor
+	cmp	\dividend, \divisor,  lsr #1
+	subhs	\dividend, \dividend, \divisor, lsr #1
+	cmp	\dividend, \divisor,  lsr #2
+	subhs	\dividend, \dividend, \divisor, lsr #2
+	cmp	\dividend, \divisor,  lsr #3
+	subhs	\dividend, \dividend, \divisor, lsr #3
+	cmp	\dividend, #1
+	mov	\divisor, \divisor, lsr #4
+	subges	\order, \order, #4
+	bge	1b
+
+	tst	\order, #3
+	teqne	\dividend, #0
+	beq	5f
+
+	@ Either 1, 2 or 3 comparison/substractions are left.
+2:	cmn	\order, #2
+	blt	4f
+	beq	3f
+	cmp	\dividend, \divisor
+	subhs	\dividend, \dividend, \divisor
+	mov	\divisor,  \divisor,  lsr #1
+3:	cmp	\dividend, \divisor
+	subhs	\dividend, \dividend, \divisor
+	mov	\divisor,  \divisor,  lsr #1
+4:	cmp	\dividend, \divisor
+	subhs	\dividend, \dividend, \divisor
+5:
+.endm
+
+
+ENTRY(__udivsi3)
+ENTRY(__aeabi_uidiv)
+
+	subs	r2, r1, #1
+	moveq	pc, lr
+	bcc	Ldiv0
+	cmp	r0, r1
+	bls	11f
+	tst	r1, r2
+	beq	12f
+
+	ARM_DIV_BODY r0, r1, r2, r3
+
+	mov	r0, r2
+	mov	pc, lr
+
+11:	moveq	r0, #1
+	movne	r0, #0
+	mov	pc, lr
+
+12:	ARM_DIV2_ORDER r1, r2
+
+	mov	r0, r0, lsr r2
+	mov	pc, lr
+
+ENDPROC(__udivsi3)
+ENDPROC(__aeabi_uidiv)
+
+ENTRY(__umodsi3)
+
+	subs	r2, r1, #1			@ compare divisor with 1
+	bcc	Ldiv0
+	cmpne	r0, r1				@ compare dividend with divisor
+	moveq   r0, #0
+	tsthi	r1, r2				@ see if divisor is power of 2
+	andeq	r0, r0, r2
+	movls	pc, lr
+
+	ARM_MOD_BODY r0, r1, r2, r3
+
+	mov	pc, lr
+
+ENDPROC(__umodsi3)
+
+ENTRY(__divsi3)
+ENTRY(__aeabi_idiv)
+
+	cmp	r1, #0
+	eor	ip, r0, r1			@ save the sign of the result.
+	beq	Ldiv0
+	rsbmi	r1, r1, #0			@ loops below use unsigned.
+	subs	r2, r1, #1			@ division by 1 or -1 ?
+	beq	10f
+	movs	r3, r0
+	rsbmi	r3, r0, #0			@ positive dividend value
+	cmp	r3, r1
+	bls	11f
+	tst	r1, r2				@ divisor is power of 2 ?
+	beq	12f
+
+	ARM_DIV_BODY r3, r1, r0, r2
+
+	cmp	ip, #0
+	rsbmi	r0, r0, #0
+	mov	pc, lr
+
+10:	teq	ip, r0				@ same sign ?
+	rsbmi	r0, r0, #0
+	mov	pc, lr
+
+11:	movlo	r0, #0
+	moveq	r0, ip, asr #31
+	orreq	r0, r0, #1
+	mov	pc, lr
+
+12:	ARM_DIV2_ORDER r1, r2
+
+	cmp	ip, #0
+	mov	r0, r3, lsr r2
+	rsbmi	r0, r0, #0
+	mov	pc, lr
+
+ENDPROC(__divsi3)
+ENDPROC(__aeabi_idiv)
+
+ENTRY(__modsi3)
+
+	cmp	r1, #0
+	beq	Ldiv0
+	rsbmi	r1, r1, #0			@ loops below use unsigned.
+	movs	ip, r0				@ preserve sign of dividend
+	rsbmi	r0, r0, #0			@ if negative make positive
+	subs	r2, r1, #1			@ compare divisor with 1
+	cmpne	r0, r1				@ compare dividend with divisor
+	moveq	r0, #0
+	tsthi	r1, r2				@ see if divisor is power of 2
+	andeq	r0, r0, r2
+	bls	10f
+
+	ARM_MOD_BODY r0, r1, r2, r3
+
+10:	cmp	ip, #0
+	rsbmi	r0, r0, #0
+	mov	pc, lr
+
+ENDPROC(__modsi3)
+
+#ifdef CONFIG_AEABI
+
+ENTRY(__aeabi_uidivmod)
+
+	stmfd	sp!, {r0, r1, ip, lr}
+	bl	__aeabi_uidiv
+	ldmfd	sp!, {r1, r2, ip, lr}
+	mul	r3, r0, r2
+	sub	r1, r1, r3
+	mov	pc, lr
+
+ENDPROC(__aeabi_uidivmod)
+
+ENTRY(__aeabi_idivmod)
+
+	stmfd	sp!, {r0, r1, ip, lr}
+	bl	__aeabi_idiv
+	ldmfd	sp!, {r1, r2, ip, lr}
+	mul	r3, r0, r2
+	sub	r1, r1, r3
+	mov	pc, lr
+
+ENDPROC(__aeabi_idivmod)
+
+#endif
+
+Ldiv0:
+
+	str	lr, [sp, #-8]!
+	bl	__div0
+	mov	r0, #0			@ About as wrong as it could be.
+	ldr	pc, [sp], #8
+
+
Binary files linux-2.6.33/arch/arm/boot/compressed/piggy.gzip and linux-2.6.33.modified/arch/arm/boot/compressed/piggy.gzip differ
diff --exclude CVS --exclude .git -uNr linux-2.6.33/arch/arm/mach-lpc313x/generic.c linux-2.6.33.modified/arch/arm/mach-lpc313x/generic.c
--- linux-2.6.33/arch/arm/mach-lpc313x/generic.c	2012-10-01 21:38:07.589085016 -0700
+++ linux-2.6.33.modified/arch/arm/mach-lpc313x/generic.c	2012-10-01 17:57:09.611154448 -0700
@@ -201,8 +201,8 @@
 	gpio_request(GPIO_BOOT1, "boot1");
 	gpio_direction_input(GPIO_BOOT1);
 	gpio_export(GPIO_BOOT1, 1);
-	gpio_request(GPIO_BOOT2, "boot2");  //cpu idle indicator drives this
-	gpio_direction_output(GPIO_BOOT2, 1);
+   gpio_request(GPIO_BOOT2, "boot2");  //cpu idle indicator drives this
+   gpio_direction_output(GPIO_BOOT2, 1);
 	gpio_export(GPIO_BOOT2, 0);
 }
 
diff --exclude CVS --exclude .git -uNr linux-2.6.33/arch/arm/mach-lpc313x/generic.c~ linux-2.6.33.modified/arch/arm/mach-lpc313x/generic.c~
--- linux-2.6.33/arch/arm/mach-lpc313x/generic.c~	2012-10-01 21:38:07.497087058 -0700
+++ linux-2.6.33.modified/arch/arm/mach-lpc313x/generic.c~	1969-12-31 16:00:00.000000000 -0800
@@ -1,294 +0,0 @@
-/*  arch/arm/mach-lpc313x/generic.c
- *
- *  Author:	Durgesh Pattamatta
- *  Copyright (C) 2009 NXP semiconductors
- *
- *  Common code for machines with LPC313x and LPC315x SoCs.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- *
- */
-#include <linux/platform_device.h>
-#include <linux/init.h>
-#include <linux/kernel.h>
-#include <linux/module.h>
-#include <linux/string.h>
-#include <linux/console.h>
-#include <linux/serial_8250.h>
-
-#include <asm/errno.h>
-#include <mach/hardware.h>
-
-#include <mach/gpio.h>
-#include <asm/mach/map.h>
-
-/* local functions */
-
-static void lpc313x_uart_pm(struct uart_port * port, unsigned int state,
-			      unsigned int oldstate)
-{
-	switch (state) {
-	case 0:
-		/* Free the pins so that UART IP will take control of it */
-#if 0
-		/* XXX fix this mess */
-		lpc313x_gpio_ip_driven(GPIO_UART_RXD);
-		lpc313x_gpio_ip_driven(GPIO_UART_TXD);
-#endif
-		/*
-		 * Enable the peripheral clock for this serial port.
-		 * This is called on uart_open() or a resume event.
-		 */
-		/* Enable UART base clock */
-		cgu_endis_base_freq(CGU_SB_UARTCLK_BASE_ID, 1);
-
-		/* Enable UART IP clock */
-		cgu_clk_en_dis(CGU_SB_UART_U_CLK_ID, 1);
-		cgu_clk_en_dis(CGU_SB_UART_APB_CLK_ID, 1);
-		break;
-	case 1:
-		/* we can wake the system in this state. So leave clocks on */
-		printk(KERN_INFO "lpc313x_uart_pm: UART can wake\n");
-		break;
-	case 3:
-		/*
-		 * Disable the peripheral clock for this serial port.
-		 * This is called on uart_close() or a suspend event.
-		 */
-		/* Disable UART IP clock */
-		cgu_clk_en_dis(CGU_SB_UART_U_CLK_ID, 0);
-		cgu_clk_en_dis(CGU_SB_UART_APB_CLK_ID, 0);
-
-		/* Disable UART base clock */
-		cgu_endis_base_freq(CGU_SB_UARTCLK_BASE_ID, 0);
-
-		/* XXX fix this mess */
-#if 0
-		lpc313x_gpio_direction_input(GPIO_UART_RXD);
-		lpc313x_gpio_set_value(GPIO_UART_TXD, 0);
-#endif
-		break;
-	default:
-		printk(KERN_ERR "lpc313x_uart_pm: unknown pm %d\n", state);
-	}
-
-}
-
-static struct plat_serial8250_port platform_serial_ports[] = {
-	{
-		.membase = (void *)io_p2v(UART_PHYS),
-		.mapbase = (unsigned long)UART_PHYS,
-		.irq = IRQ_UART,
-		.uartclk = XTAL_CLOCK,
-		.regshift = 2,
-		.iotype = UPIO_MEM,
-		.flags = UPF_BOOT_AUTOCONF | UPF_BUGGY_UART | UPF_SKIP_TEST,
-		.pm = lpc313x_uart_pm,
-	},
-	{
-		.flags		= 0
-	},
-};
-
-static struct platform_device serial_device = {
-	.name = "serial8250",
-	.id = PLAT8250_DEV_PLATFORM,
-	.dev = {
-		.platform_data = &platform_serial_ports,
-	},
-};
-
-#if defined(CONFIG_HW_RANDOM_LPC313X) || defined(CONFIG_HW_RANDOM_LPC313X_MODULE)
-
-static struct resource rng_resources[] = {
-	{
-		.start = RNG_PHYS,
-		.end   = RNG_PHYS + 4096,
-		.flags = IORESOURCE_MEM,
-	},
-};
-
-static struct platform_device rng_device = {
-	.name = "lpc313x-rng",
-	.id   = -1,
-	.num_resources = ARRAY_SIZE(rng_resources),
-	.resource = rng_resources,
-};
-
-#endif
-
-static struct platform_device *devices[] __initdata = {
-	&serial_device,
-#if defined(CONFIG_HW_RANDOM_LPC313X) || defined(CONFIG_HW_RANDOM_LPC313X_MODULE)
-	&rng_device,
-#endif
-};
-
-static struct map_desc lpc313x_io_desc[] __initdata = {
-	{
-		.virtual	= io_p2v(IO_INTC_PHYS),
-		.pfn		= __phys_to_pfn(IO_INTC_PHYS),
-		.length		= IO_INTC_SIZE,
-		.type		= MT_DEVICE
-	},
-	{
-		.virtual	= io_p2v(IO_APB01_PHYS),
-		.pfn		= __phys_to_pfn(IO_APB01_PHYS),
-		.length		= IO_APB01_SIZE,
-		.type		= MT_DEVICE
-	},
-	{
-		.virtual	= io_p2v(IO_APB2_PHYS),
-		.pfn		= __phys_to_pfn(IO_APB2_PHYS),
-		.length		= IO_APB2_SIZE,
-		.type		= MT_DEVICE
-	},
-	{
-		.virtual	= io_p2v(IO_APB3_PHYS),
-		.pfn		= __phys_to_pfn(IO_APB3_PHYS),
-		.length		= IO_APB3_SIZE,
-		.type		= MT_DEVICE
-	},
-	{
-		.virtual	= io_p2v(IO_APB4_PHYS),
-		.pfn		= __phys_to_pfn(IO_APB4_PHYS),
-		.length		= IO_APB4_SIZE,
-		.type		= MT_DEVICE
-	},
-	{
-		.virtual	= io_p2v(IO_DMA_REG_PHYS),
-		.pfn		= __phys_to_pfn(IO_DMA_REG_PHYS),
-		.length		= IO_DMA_REG_SIZE,
-		.type		= MT_DEVICE
-	},
-	{
-		.virtual	= io_p2v(IO_MPMC_CFG_PHYS),
-		.pfn		= __phys_to_pfn(IO_MPMC_CFG_PHYS),
-		.length		= IO_MPMC_CFG_SIZE,
-		.type		= MT_DEVICE
-	},
-	{
-		.virtual	= io_p2v(IO_NAND_BUF_PHYS),
-		.pfn		= __phys_to_pfn(IO_NAND_BUF_PHYS),
-		.length		= IO_NAND_BUF_SIZE,
-		.type		= MT_DEVICE
-	},
-	{
-		.virtual	= io_p2v(IO_ISRAM0_PHYS),
-		.pfn		= __phys_to_pfn(IO_ISRAM0_PHYS),
-		.length		= IO_ISRAM0_SIZE,
-		.type		= MT_DEVICE
-	},
-};
-
-void __init lpc313x_map_io(void)
-{
-	iotable_init(lpc313x_io_desc, ARRAY_SIZE(lpc313x_io_desc));
-}
-extern int __init cgu_init(char *str);
-
-int __init lpc313x_init(void)
-{
-	/* cgu init */
-	cgu_init("");
-	/* Switch on the UART clocks */
-	cgu_clk_en_dis(CGU_SB_UART_APB_CLK_ID, 1);
-	cgu_clk_en_dis(CGU_SB_UART_U_CLK_ID, 1);
-	cgu_clk_en_dis(CGU_SB_IOCONF_PCLK_ID, 1);
-
-	/* Put adc block in low power state.
-	 * Once ADC driver is added this should move to driver.
-	 */
-	SYS_ADC_PD = 1;
-	/* Disable ring oscillators used by Random number generators */
-	SYS_RNG_OSC_CFG = 0;
-
-	/* Mux I2S signals based on selected channel */
-#if defined (CONFIG_SND_I2S_TX0_MASTER)
-	/* I2S TX0 WS, DATA */
-	GPIO_DRV_IP(IOCONF_EBI_I2STX_0, 0x60);
-
-	/* I2S TX0 BCK */
-	GPIO_DRV_IP(IOCONF_EBI_MCI, 0x80);
-#endif
-
-#if defined (CONFIG_SND_I2S_TX1_MASTER)
-	/* I2S TX1 BCK, WS, DATA */
-	GPIO_DRV_IP(IOCONF_I2STX_1, 0x7);
-#endif
-
-#if defined (CONFIG_SND_I2S_RX0_MASTER) | defined (CONFIG_SND_I2S_RX0_SLAVE)
-	/* I2S RX0 BCK, WS, DATA */
-	GPIO_DRV_IP(IOCONF_I2SRX_0, 0x7);
-#endif
-#if defined (CONFIG_SND_I2S_RX1_MASTER) | defined (CONFIG_SND_I2S_RX1_SLAVE)
-	/* I2S RX1 BCK, WS, DATA */
-	GPIO_DRV_IP(IOCONF_I2SRX_1, 0x7);
-#endif
-	/* AUDIO CODEC CLOCK (256FS) */
-	GPIO_DRV_IP(IOCONF_I2STX_1, 0x8);
-
-	lpc313x_gpiolib_init();
-
-	return platform_add_devices(devices, ARRAY_SIZE(devices));
-}
-
-
-#if defined(CONFIG_SERIAL_8250_CONSOLE)
-static int __init lpc313x_init_console(void)
-{
-	static __initdata char serr[] =
-		KERN_ERR "Serial port #%u setup failed\n";
-	struct uart_port up;
-	int mul, div;
-
-	/* Switch on the UART clocks */
-	cgu_clk_en_dis(CGU_SB_UART_APB_CLK_ID, 1);
-	cgu_clk_en_dis(CGU_SB_UART_U_CLK_ID, 1);
-
- 	/*
-	 * Set up serial port #0. Do not use autodetection; the result is
-	 * not what we want.
- 	 */
-	memset(&up, 0, sizeof(up));
-
-	up.membase = (char *) io_p2v(UART_PHYS);
-	up.mapbase = (unsigned long)UART_PHYS,
-	up.irq = IRQ_UART;
-	up.uartclk = XTAL_CLOCK;
-	/* check what FDR bootloader is using */
-	mul = (UART_FDR_REG >> 4) & 0xF;
-	div = UART_FDR_REG & 0xF;
-	if (div != 0)  {
-		up.uartclk = (XTAL_CLOCK * mul) / (mul + div); 
-	} 
-	up.regshift = 2;
-	up.iotype = UPIO_MEM;
-	up.type	= PORT_NXP16750;
-	up.flags = UPF_BOOT_AUTOCONF | UPF_BUGGY_UART | UPF_SKIP_TEST;
-	up.line	= 0;
-	platform_serial_ports[0].uartclk = up.uartclk;
-	if (early_serial_setup(&up))
-		printk(serr, up.line);
-
-	return 0;
-}
-console_initcall(lpc313x_init_console);
-
-#endif /*CONFIG_SERIAL_8250_CONSOLE*/
-
-
-
-
diff --exclude CVS --exclude .git -uNr linux-2.6.33/drivers/mmc/host/lpc313x_mmc.c~ linux-2.6.33.modified/drivers/mmc/host/lpc313x_mmc.c~
--- linux-2.6.33/drivers/mmc/host/lpc313x_mmc.c~	2012-10-01 21:38:07.413088921 -0700
+++ linux-2.6.33.modified/drivers/mmc/host/lpc313x_mmc.c~	1969-12-31 16:00:00.000000000 -0800
@@ -1,1638 +0,0 @@
-/*
- * LPC313x MultiMedia Card Interface driver
- *
- * drivers/mmc/host/lpc313x_mmc.c
- *
- * Copyright (C) 2009 NXP Semiconductors
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- *
- */
-#include <linux/blkdev.h>
-#include <linux/clk.h>
-#include <linux/debugfs.h>
-#include <linux/device.h>
-#include <linux/dma-mapping.h>
-#include <linux/err.h>
-#include <linux/init.h>
-#include <linux/interrupt.h>
-#include <linux/ioport.h>
-#include <linux/module.h>
-#include <linux/platform_device.h>
-#include <linux/scatterlist.h>
-#include <linux/seq_file.h>
-#include <linux/stat.h>
-#include <linux/delay.h>
-#include <linux/irq.h>
-
-#include "lpc313x_mmc.h"
-#include <mach/irqs.h>
-#include <linux/mmc/host.h>
-#include <mach/board.h>
-/* for time being use arch specific DMA framework instead of generic framework */
-#include <mach/dma.h>
-
-#define USE_DMA
-#define BURST_DMA
-
-#define LPC313x_MCI_DATA_ERROR_FLAGS	(SDMMC_INT_DTO | SDMMC_INT_DCRC | SDMMC_INT_HTO | SDMMC_INT_SBE | SDMMC_INT_EBE)
-#define LPC313x_MCI_CMD_ERROR_FLAGS	(SDMMC_INT_RTO | SDMMC_INT_RCRC | SDMMC_INT_RESP_ERR | SDMMC_INT_HLE)
-#define LPC313x_MCI_ERROR_FLAGS		(LPC313x_MCI_DATA_ERROR_FLAGS | LPC313x_MCI_CMD_ERROR_FLAGS | SDMMC_INT_HLE)
-#define LPC313x_MCI_SEND_STATUS		1
-#define LPC313x_MCI_RECV_STATUS		2
-#define LPC313x_MCI_DMA_THRESHOLD	16
-
-enum {
-	EVENT_CMD_COMPLETE = 0,
-	EVENT_XFER_COMPLETE,
-	EVENT_DATA_COMPLETE,
-	EVENT_DATA_ERROR,
-	EVENT_XFER_ERROR
-};
-
-
-enum lpc313x_mci_state {
-	STATE_IDLE = 0,
-	STATE_SENDING_CMD,
-	STATE_SENDING_DATA,
-	STATE_DATA_BUSY,
-	STATE_SENDING_STOP,
-	STATE_DATA_ERROR,
-};
-/*forward declaration */
-struct lpc313x_mci_slot;
-
-struct lpc313x_mci {
-	spinlock_t		lock;
-	void __iomem		*regs;
-
-	struct scatterlist	*sg;
-	unsigned int		pio_offset;
-
-	struct lpc313x_mci_slot	*cur_slot;
-	struct mmc_request	*mrq;
-	struct mmc_command	*cmd;
-	struct mmc_data		*data;
-
-#ifdef USE_DMA
-	int			dma_chn;
-	dma_addr_t		sg_dma;
-	dma_sg_ll_t		*sg_cpu;
-#endif
-	u32			cmd_status;
-	u32			data_status;
-	u32			stop_cmdr;
-	u32			dir_status;
-	struct tasklet_struct	tasklet;
-	unsigned long		pending_events;
-	unsigned long		completed_events;
-	enum lpc313x_mci_state	state;
-	struct list_head	queue;
-
-	u32			bus_hz;
-	u32			current_speed;
-	struct platform_device	*pdev;
-	struct lpc313x_mci_board *pdata;
-	struct lpc313x_mci_slot	*slot[MAX_MCI_SLOTS];
-};
-
-struct lpc313x_mci_slot {
-	struct mmc_host		*mmc;
-	struct lpc313x_mci	*host;
-
-	u32			ctype;
-
-	struct mmc_request	*mrq;
-	struct list_head	queue_node;
-
-	unsigned int		clock;
-	unsigned long		flags;
-#define LPC313x_MMC_CARD_PRESENT	0
-#define LPC313x_MMC_CARD_NEED_INIT	1
-#define LPC313x_MMC_SHUTDOWN		2
-	int			id;
-	int			irq;
-
-	struct timer_list	detect_timer;
-};
-
-#define lpc313x_mci_test_and_clear_pending(host, event)		\
-	test_and_clear_bit(event, &host->pending_events)
-#define lpc313x_mci_set_completed(host, event)			\
-	set_bit(event, &host->completed_events)
-
-#define lpc313x_mci_set_pending(host, event)				\
-	set_bit(event, &host->pending_events)
-
-#if defined (CONFIG_DEBUG_FS)
-/*
- * The debugfs stuff below is mostly optimized away when
- * CONFIG_DEBUG_FS is not set.
- */
-static int lpc313x_mci_req_show(struct seq_file *s, void *v)
-{
-	struct lpc313x_mci_slot	*slot = s->private;
-	struct mmc_request	*mrq;
-	struct mmc_command	*cmd;
-	struct mmc_command	*stop;
-	struct mmc_data		*data;
-
-	/* Make sure we get a consistent snapshot */
-	spin_lock(&slot->host->lock);
-	mrq = slot->mrq;
-
-	if (mrq) {
-		cmd = mrq->cmd;
-		data = mrq->data;
-		stop = mrq->stop;
-
-		if (cmd)
-			seq_printf(s,
-				"CMD%u(0x%x) flg %x rsp %x %x %x %x err %d\n",
-				cmd->opcode, cmd->arg, cmd->flags,
-				cmd->resp[0], cmd->resp[1], cmd->resp[2],
-				cmd->resp[2], cmd->error);
-		if (data)
-			seq_printf(s, "DATA %u / %u * %u flg %x err %d\n",
-				data->bytes_xfered, data->blocks,
-				data->blksz, data->flags, data->error);
-		if (stop)
-			seq_printf(s,
-				"CMD%u(0x%x) flg %x rsp %x %x %x %x err %d\n",
-				stop->opcode, stop->arg, stop->flags,
-				stop->resp[0], stop->resp[1], stop->resp[2],
-				stop->resp[2], stop->error);
-	}
-
-	spin_unlock(&slot->host->lock);
-
-	return 0;
-}
-
-static int lpc313x_mci_req_open(struct inode *inode, struct file *file)
-{
-	return single_open(file, lpc313x_mci_req_show, inode->i_private);
-}
-
-static const struct file_operations lpc313x_mci_req_fops = {
-	.owner		= THIS_MODULE,
-	.open		= lpc313x_mci_req_open,
-	.read		= seq_read,
-	.llseek		= seq_lseek,
-	.release	= single_release,
-};
-
-static int lpc313x_mci_regs_show(struct seq_file *s, void *v)
-{
-	struct lpc313x_mci	*host = s->private;
-
-	seq_printf(s, "STATUS:\t0x%08x\n",SDMMC_STATUS);
-	seq_printf(s, "RINTSTS:\t0x%08x\n",SDMMC_RINTSTS);
-	seq_printf(s, "CMD:\t0x%08x\n", SDMMC_CMD);
-	seq_printf(s, "CTRL:\t0x%08x\n", SDMMC_CTRL);
-	seq_printf(s, "INTMASK:\t0x%08x\n", SDMMC_INTMASK);
-	seq_printf(s, "CLKENA:\t0x%08x\n", SDMMC_CLKENA);
-
-	return 0;
-}
-
-static int lpc313x_mci_regs_open(struct inode *inode, struct file *file)
-{
-	return single_open(file, lpc313x_mci_regs_show, inode->i_private);
-}
-
-static const struct file_operations lpc313x_mci_regs_fops = {
-	.owner		= THIS_MODULE,
-	.open		= lpc313x_mci_regs_open,
-	.read		= seq_read,
-	.llseek		= seq_lseek,
-	.release	= single_release,
-};
-
-static void lpc313x_mci_init_debugfs(struct lpc313x_mci_slot *slot)
-{
-	struct mmc_host		*mmc = slot->mmc;
-	struct lpc313x_mci	*host = slot->host;
-	struct dentry		*root;
-	struct dentry		*node;
-
-	root = mmc->debugfs_root;
-	if (!root)
-		return;
-
-	node = debugfs_create_file("regs", S_IRUSR, root, host,
-			&lpc313x_mci_regs_fops);
-	if (IS_ERR(node))
-		return;
-	if (!node)
-		goto err;
-
-	node = debugfs_create_file("req", S_IRUSR, root, slot, &lpc313x_mci_req_fops);
-	if (!node)
-		goto err;
-
-	node = debugfs_create_u32("state", S_IRUSR, root, (u32 *)&host->state);
-	if (!node)
-		goto err;
-
-	node = debugfs_create_x32("pending_events", S_IRUSR, root,
-				     (u32 *)&host->pending_events);
-	if (!node)
-		goto err;
-
-	node = debugfs_create_x32("completed_events", S_IRUSR, root,
-				     (u32 *)&host->completed_events);
-	if (!node)
-		goto err;
-
-	return;
-
-err:
-	dev_err(&mmc->class_dev, "failed to initialize debugfs for slot\n");
-}
-#endif
-
-static inline unsigned ns_to_clocks(unsigned clkrate, unsigned ns)
-{
-	u32 clks;
-	if (clkrate > 1000000)
-		clks =  (ns * (clkrate / 1000000) + 999) / 1000;
-	else
-		clks =  ((ns/1000) * (clkrate / 1000) + 999) / 1000;
-
-	return clks;
-}
-
-static void lpc313x_mci_set_timeout(struct lpc313x_mci *host,
-		struct lpc313x_mci_slot *slot, struct mmc_data *data)
-{
-	unsigned timeout;
-
-	timeout = ns_to_clocks(slot->clock, data->timeout_ns) + data->timeout_clks;
-
-	dev_vdbg(&slot->mmc->class_dev, "tmo req:%d + %d reg:%d clk:%d\n", 
-		data->timeout_ns, data->timeout_clks, timeout, slot->clock);
-	/* the standard response timeout value (Ncr) is 64 clocks. 
-	 * Let give 4 additional clocks for response.
-	 */
-	mci_writel(TMOUT, /*0xffffffff); */ (timeout << 8) | (70));
-}
-
-static u32 lpc313x_mci_prepare_command(struct mmc_host *mmc,
-				 struct mmc_command *cmd)
-{
-	struct mmc_data	*data;
-	u32		cmdr;
-	
-	cmd->error = -EINPROGRESS;
-	cmdr = cmd->opcode;
-
-	if(cmdr == 12) 
-		cmdr |= SDMMC_CMD_STOP;
-	else 
-		cmdr |= SDMMC_CMD_PRV_DAT_WAIT;
-
-	if (cmd->flags & MMC_RSP_PRESENT) {
-		cmdr |= SDMMC_CMD_RESP_EXP; // expect the respond, need to set this bit
-		if (cmd->flags & MMC_RSP_136) 
-			cmdr |= SDMMC_CMD_RESP_LONG; // expect long respond
-		
-		if(cmd->flags & MMC_RSP_CRC) 
-			cmdr |= SDMMC_CMD_RESP_CRC;
-	}
-
-	data = cmd->data;
-	if (data) {
-		cmdr |= SDMMC_CMD_DAT_EXP;
-		if (data->flags & MMC_DATA_STREAM) 
-			cmdr |= SDMMC_CMD_STRM_MODE; //  set stream mode
-		if (data->flags & MMC_DATA_WRITE) 
-		    cmdr |= SDMMC_CMD_DAT_WR;
-		
-#if 0 /* Jerry, need to confirm the specification does we need to set this bit if blocks > 1 */
-		if(data->blocks > 1) 
-		    cmdr |= SDMMC_CMD_SEND_STOP;
-		
-#endif
-	}
-	return cmdr;
-}
-
-
-static void lpc313x_mci_start_command(struct lpc313x_mci *host,
-		struct mmc_command *cmd, u32 cmd_flags)
-{
- 	int tmo = 50;
- 	host->cmd = cmd;
-	dev_vdbg(&host->pdev->dev,
-			"start cmd:%d ARGR=0x%08x CMDR=0x%08x\n",
-			cmd->opcode, cmd->arg, cmd_flags);
-	mci_writel(CMDARG, cmd->arg); // write to CMDARG register
-	mci_writel(CMD, cmd_flags | SDMMC_CMD_START); // write to CMD register
-
-	/* wait until CIU accepts the command */
-	while (--tmo && (mci_readl(CMD) & SDMMC_CMD_START)) 
-		cpu_relax();
-}
-
-static void send_stop_cmd(struct lpc313x_mci *host, struct mmc_data *data)
-{
-	lpc313x_mci_start_command(host, data->stop, host->stop_cmdr);
-}
-
-
-#ifdef USE_DMA
-
-static void lpc313x_mci_dma_cleanup(struct lpc313x_mci *host)
-{
-	struct mmc_data			*data = host->data;
-
-	if (data) 
-		dma_unmap_sg(&host->pdev->dev, data->sg, data->sg_len,
-		     ((data->flags & MMC_DATA_WRITE)
-		      ? DMA_TO_DEVICE : DMA_FROM_DEVICE));
-}
-
-static void lpc313x_mci_stop_dma(struct lpc313x_mci *host)
-{
-	if (host->dma_chn > 0) {
-		dma_stop_channel(host->dma_chn);
-		lpc313x_mci_dma_cleanup(host);
-	} else {
-		/* Data transfer was stopped by the interrupt handler */
-		lpc313x_mci_set_pending(host, EVENT_XFER_COMPLETE);
-	}
-}
-
-/* This function is called by the DMA driver from tasklet context. */
-static void lpc313x_mci_dma_complete(int chn, dma_irq_type_t type, void *arg)
-{
-	struct lpc313x_mci	*host = arg;
-	struct mmc_data		*data = host->data;
-
-	dev_vdbg(&host->pdev->dev, "DMA complete\n");
-
-	spin_lock(&host->lock);
-	lpc313x_mci_dma_cleanup(host);
-
-	/*
-	 * If the card was removed, data will be NULL. No point trying
-	 * to send the stop command or waiting for NBUSY in this case.
-	 */
-	if (data) {
-		lpc313x_mci_set_pending(host, EVENT_XFER_COMPLETE);
-		tasklet_schedule(&host->tasklet);
-	}
-	spin_unlock(&host->lock);
-}
-
-static int lpc313x_mci_submit_data_dma(struct lpc313x_mci *host, struct mmc_data *data)
-{
-	struct scatterlist		*sg;
-	unsigned int			i, direction, sg_len;
-	unsigned int			j, trans_len;
-
-	/* If we don't have a channel, we can't do DMA */
-	if (host->dma_chn < 0)
-		return -ENODEV;
-
-	/*
-	 * We don't do DMA on "complex" transfers, i.e. with
-	 * non-word-aligned buffers or lengths. Also, we don't bother
-	 * with all the DMA setup overhead for short transfers.
-	 */
-	if (data->blocks * data->blksz < LPC313x_MCI_DMA_THRESHOLD)
-		return -EINVAL;
-	if (data->blksz & 3)
-		return -EINVAL;
-
-	for_each_sg(data->sg, sg, data->sg_len, i) {
-		if (sg->offset & 3 || sg->length & 3)
-			return -EINVAL;
-	}
-
-	if (data->flags & MMC_DATA_READ)
-		direction = DMA_FROM_DEVICE;
-	else
-		direction = DMA_TO_DEVICE;
-
-	sg_len = dma_map_sg(&host->pdev->dev, data->sg, data->sg_len,
-				   direction);
-
-	dev_vdbg(&host->pdev->dev, "sd sg_cpu: 0x%08x sg_dma:0x%08x sg_len:%d \n",
-		(u32)host->sg_cpu, (u32)host->sg_dma, sg_len);
-
-	for (i = 0, j = 0; i < sg_len; i++) {
-		unsigned int length = sg_dma_len(&data->sg[i]);
-		u32 mem_addr = sg_dma_address(&data->sg[i]);
-
-		while (length) {
-
-			host->sg_cpu[j].setup.cfg = DMA_CFG_CMP_CH_EN | DMA_CFG_CMP_CH_NR(host->dma_chn);
-
-			if (data->flags & MMC_DATA_READ) {
-				host->sg_cpu[j].setup.src_address = SDMMC_DATA_ADR;
-				host->sg_cpu[j].setup.dest_address = mem_addr;
-				host->sg_cpu[j].setup.cfg |= DMA_CFG_RD_SLV_NR(DMA_SLV_SDMMC);
-			} else {
-				host->sg_cpu[j].setup.src_address = mem_addr;
-				host->sg_cpu[j].setup.dest_address = SDMMC_DATA_ADR;
-				host->sg_cpu[j].setup.cfg |= DMA_CFG_WR_SLV_NR(DMA_SLV_SDMMC);
-			}
-			host->sg_cpu[j].next_entry = host->sg_dma + (j + 1) *
-						sizeof(dma_sg_ll_t);
-
-#ifdef BURST_DMA
-			host->sg_cpu[j].setup.cfg |= DMA_CFG_TX_BURST;
-      /* 16 bytes per transfer */
-			trans_len = (length >> 4) - 1;
-#else
-      /* 4 bytes per transfer */
-			trans_len = (length >> 2) - 1;
-#endif
-
-			if (trans_len > DMA_MAX_TRANSFERS) {
-				trans_len = DMA_MAX_TRANSFERS;
-				length -= (DMA_MAX_TRANSFERS + 1) << 2;
-				mem_addr += ((DMA_MAX_TRANSFERS + 1) << 2);
-			}
-			else {
-				length = 0;
-			}
-
-			host->sg_cpu[j].setup.trans_length = trans_len;
-
-			dev_vdbg(&host->pdev->dev, "sd src: 0x%08x dest:0x%08x cfg:0x%08x nxt:0x%08x len:%d \n",
-				host->sg_cpu[j].setup.src_address, host->sg_cpu[j].setup.dest_address,
-				host->sg_cpu[j].setup.cfg, host->sg_cpu[j].next_entry,
-				host->sg_cpu[j].setup.trans_length);
-
-			/* move to next transfer descriptor */
-			j++;
-		}
-	}
-	host->sg_cpu[j].setup.src_address = host->sg_dma;
-	host->sg_cpu[j].setup.dest_address = DMACH_SOFT_INT_PHYS;
-	host->sg_cpu[j].setup.trans_length = 1;
-	host->sg_cpu[j].setup.cfg = 0;
-	// disable irq of RX & TX, let DMA handle it
-	//SDMMC_INTMASK &= ~(SDMMC_INT_RXDR | SDMMC_INT_TXDR);
-	SDMMC_CTRL |= SDMMC_CTRL_DMA_ENABLE; // enable dma
-	dma_prog_sg_channel(host->dma_chn, host->sg_dma);
-	wmb();
-	/* Go! */
-	dma_start_channel(host->dma_chn);
-
-	return 0;
-}
-
-#else
-static int lpc313x_mci_submit_data_dma(struct lpc313x_mci *host, struct mmc_data *data)
-{
-	return -ENOSYS;
-}
-
-static void lpc313x_mci_stop_dma(struct lpc313x_mci *host)
-{
-	/* Data transfer was stopped by the interrupt handler */
-	lpc313x_mci_set_pending(host, EVENT_XFER_COMPLETE);
-}
-#endif
-
-static void lpc313x_mci_submit_data(struct lpc313x_mci *host, struct mmc_data *data)
-{
-	data->error = -EINPROGRESS;
-
-	WARN_ON(host->data);
-	host->sg = NULL;
-	host->data = data;
-
-	if (lpc313x_mci_submit_data_dma(host, data)) {
-		host->sg = data->sg;
-		host->pio_offset = 0;
-		if (data->flags & MMC_DATA_READ)
-			host->dir_status = LPC313x_MCI_RECV_STATUS;
-		else 
-			host->dir_status = LPC313x_MCI_SEND_STATUS;
-
-		//SDMMC_INTMASK |= (SDMMC_INT_RXDR | SDMMC_INT_TXDR);
-		SDMMC_CTRL &= ~SDMMC_CTRL_DMA_ENABLE; // enable dma
-	}
-
-}
-
-#define mci_send_cmd(cmd,arg) {	\
-    SDMMC_CMDARG = arg;		\
-    SDMMC_CMD = SDMMC_CMD_START | cmd;\
-    while (SDMMC_CMD & SDMMC_CMD_START); \
-}
-
-void lpc313x_mci_setup_bus(struct lpc313x_mci_slot *slot)
-{
-	struct lpc313x_mci *host = slot->host;
-	u32 div;
-
-	if (slot->clock != host->current_speed) {
-		div  = (((host->bus_hz + (host->bus_hz / 5)) / slot->clock)) >> 1;
-
-		dev_dbg(&slot->mmc->class_dev, "Bus speed (slot %d) = %dHz div:%d (actual %dHz)\n",
-			slot->id, slot->clock, div, (host->bus_hz / div) >> 1);
-		
-		/* store the actual clock for calculations */
-		slot->clock = (host->bus_hz / div) >> 1;
-		/* disable clock */
-		mci_writel(CLKENA, 0);
-		mci_writel(CLKSRC,0);
-		/* inform CIU */
-		mci_send_cmd( SDMMC_CMD_UPD_CLK | SDMMC_CMD_PRV_DAT_WAIT, 0);
-		/* set clock to desired speed */
-		mci_writel(CLKDIV, div);
-		/* inform CIU */
-		mci_send_cmd( SDMMC_CMD_UPD_CLK | SDMMC_CMD_PRV_DAT_WAIT, 0);
-		/* enable clock */
-		mci_writel(CLKENA, SDMMC_CLKEN_ENABLE);
-		/* inform CIU */
-		 mci_send_cmd( SDMMC_CMD_UPD_CLK | SDMMC_CMD_PRV_DAT_WAIT, 0);
-
-		host->current_speed = slot->clock;
-	}
-
-	/* Set the current slot bus width */
-	mci_writel(CTYPE, slot->ctype);
-}
-
-static void lpc313x_mci_start_request(struct lpc313x_mci *host,
-		struct lpc313x_mci_slot *slot)
-{
-	struct mmc_request	*mrq;
-	struct mmc_command	*cmd;
-	struct mmc_data		*data;
-	u32			cmdflags;
-
-	mrq = slot->mrq;
-	/* now select the proper slot */
-	if (host->pdata->select_slot)
-		host->pdata->select_slot(slot->id);
-
-	/* Slot specific timing and width adjustment */
-	lpc313x_mci_setup_bus(slot);
-
-	host->cur_slot = slot;
-	host->mrq = mrq;
-
-	host->pending_events = 0;
-	host->completed_events = 0;
-	host->data_status = 0;
-
-	data = mrq->data;
-	if (data) {
-		lpc313x_mci_set_timeout(host, slot, data);
-		mci_writel(BYTCNT,data->blksz*data->blocks);
-		mci_writel(BLKSIZ,data->blksz);
-	}
-
-	cmd = mrq->cmd;
-	cmdflags = lpc313x_mci_prepare_command(slot->mmc, cmd);
-
-	if (unlikely(test_and_clear_bit(LPC313x_MMC_CARD_NEED_INIT, &slot->flags))) 
-	    cmdflags |= SDMMC_CMD_INIT; //this is the first command, let set send the initializtion clock
-	
-	if (data) //we may need to move this code to mci_start_command
-		lpc313x_mci_submit_data(host, data);
-
-	lpc313x_mci_start_command(host, cmd, cmdflags);
-
-	if (mrq->stop) 
-		host->stop_cmdr = lpc313x_mci_prepare_command(slot->mmc, mrq->stop);
-	
-}
-
-
-
-static void lpc313x_mci_queue_request(struct lpc313x_mci *host,
-		struct lpc313x_mci_slot *slot, struct mmc_request *mrq)
-{
-	dev_vdbg(&slot->mmc->class_dev, "queue request: state=%d\n",
-			host->state);
-
-	//printk("#");
-	spin_lock(&host->lock);
-	slot->mrq = mrq;
-	if (host->state == STATE_IDLE) {
-		host->state = STATE_SENDING_CMD;
-		lpc313x_mci_start_request(host, slot);
-	} else {
-		list_add_tail(&slot->queue_node, &host->queue);
-	}
-	spin_unlock(&host->lock);
-}
-
-
-static void lpc313x_mci_request(struct mmc_host *mmc, struct mmc_request *mrq)
-{
-	struct lpc313x_mci_slot	*slot = mmc_priv(mmc);
-	struct lpc313x_mci	*host = slot->host;
-
-	WARN_ON(slot->mrq);
-
-	if (!test_bit(LPC313x_MMC_CARD_PRESENT, &slot->flags)) {
-		mrq->cmd->error = -ENOMEDIUM;
-		mmc_request_done(mmc, mrq);
-		return;
-	}
-
-	lpc313x_mci_queue_request(host, slot, mrq);
-}
-
-static void lpc313x_mci_set_ios(struct mmc_host *mmc, struct mmc_ios *ios)
-{
-	struct lpc313x_mci_slot	*slot = mmc_priv(mmc);
-
-	slot->ctype = 0; // set default 1 bit mode
-	switch (ios->bus_width) {
-	case MMC_BUS_WIDTH_1:
-		slot->ctype = 0;
-		break;
-	case MMC_BUS_WIDTH_4:
-		slot->ctype = SDMMC_CTYPE_4BIT;
-		break;
-	}
-
-
-	if (ios->clock) {
-		spin_lock(&slot->host->lock);
-		/*
-		 * Use mirror of ios->clock to prevent race with mmc
-		 * core ios update when finding the minimum.
-		 */
-		slot->clock = ios->clock;
-
-		spin_unlock(&slot->host->lock);
-	} else {
-		spin_lock(&slot->host->lock);
-		slot->clock = 0;
-		spin_unlock(&slot->host->lock);
-	}
-
-	switch (ios->power_mode) {
-	case MMC_POWER_UP:
-		set_bit(LPC313x_MMC_CARD_NEED_INIT, &slot->flags);
-		break;
-	default:
-		break;
-	}
-}
-
-
-
-static int lpc313x_mci_get_ro(struct mmc_host *mmc)
-{
-	int			read_only = -ENOSYS;
-	struct lpc313x_mci_slot	*slot = mmc_priv(mmc);
-	struct lpc313x_mci_board *brd = slot->host->pdata;
-
-	if (brd->get_ro != NULL) {
-		read_only = brd->get_ro(slot->id);
-		dev_dbg(&mmc->class_dev, "card is %s\n",
-				read_only ? "read-only" : "read-write");
-	}
-
-	return read_only;
-}
-
-
-static int lpc313x_mci_get_cd(struct mmc_host *mmc)
-{
-	int			present = -ENOSYS;
-	struct lpc313x_mci_slot	*slot = mmc_priv(mmc);
-	struct lpc313x_mci_board *brd = slot->host->pdata;
-
-	present = !brd->get_cd(slot->id);
-	dev_vdbg(&mmc->class_dev, "card is %spresent\n", present ? "" : "not ");
-
-	return present;
-}
-
-static void lpc313x_mci_enable_sdio_irq(struct mmc_host *host, int enable)
-{
-	unsigned int reg;
-
-	if (enable) {
-		reg = mci_readl(INTMASK) | SDMMC_INT_SDIO;
-		mci_writel(INTMASK, reg);
-	}
-	else {
-		reg = mci_readl(INTMASK) & ~SDMMC_INT_SDIO;
-		mci_writel(INTMASK, reg);
-	}
-}
-
-static const struct mmc_host_ops lpc313x_mci_ops = {
-	.request	= lpc313x_mci_request,
-	.set_ios	= lpc313x_mci_set_ios,
-	.get_ro		= lpc313x_mci_get_ro,
-	.get_cd		= lpc313x_mci_get_cd,
-	.enable_sdio_irq= lpc313x_mci_enable_sdio_irq,
-};
-
-static void lpc313x_mci_request_end(struct lpc313x_mci *host, struct mmc_request *mrq)
-	__releases(&host->lock)
-	__acquires(&host->lock)
-{
-	struct lpc313x_mci_slot	*slot = NULL;
-	struct mmc_host		*prev_mmc = host->cur_slot->mmc;
-
-	WARN_ON(host->cmd || host->data);
-
-	host->cur_slot->mrq = NULL;
-	host->mrq = NULL;
-	if (!list_empty(&host->queue)) {
-		slot = list_entry(host->queue.next,
-				struct lpc313x_mci_slot, queue_node);
-		list_del(&slot->queue_node);
-		dev_vdbg(&host->pdev->dev, "list not empty: %s is next\n",
-				mmc_hostname(slot->mmc));
-		host->state = STATE_SENDING_CMD;
-		lpc313x_mci_start_request(host, slot);
-	} else {
-		dev_vdbg(&host->pdev->dev, "list empty\n");
-		host->state = STATE_IDLE;
-	}
-
-	//printk("-");
-
-	spin_unlock(&host->lock);
-	mmc_request_done(prev_mmc, mrq);
-
-	spin_lock(&host->lock);
-}
-
-static void lpc313x_mci_command_complete(struct lpc313x_mci *host,
-			struct mmc_command *cmd)
-{
-	u32		status = host->cmd_status;
-
-	host->cmd_status = 0;
-
-	if(cmd->flags & MMC_RSP_PRESENT) {
-
-	    if(cmd->flags & MMC_RSP_136) {
-
-		/* Read the response from the card (up to 16 bytes).
-		 * LPC313x MMC controller saves bits 127-96 in RESP3
-		 * for easy parsing. But the UNSTUFF_BITS macro in core/mmc.c
-		 * core/sd.c expect those bits be in resp[0]. Hence
-		 * reverse the response word order.
-		 */
-		cmd->resp[3] = mci_readl(RESP0);
-		cmd->resp[2] = mci_readl(RESP1);
-		cmd->resp[1] = mci_readl(RESP2);
-		cmd->resp[0] = mci_readl(RESP3);
-	    } else {
-	        cmd->resp[0] = mci_readl(RESP0);
-		cmd->resp[1] = 0;
-		cmd->resp[2] = 0;
-		cmd->resp[3] = 0;
-	    }
-	}
-
-	if (status & SDMMC_INT_RTO)
-		cmd->error = -ETIMEDOUT;
-	else if ((cmd->flags & MMC_RSP_CRC) && (status & SDMMC_INT_RCRC))
-		cmd->error = -EILSEQ;
-	else if (status & SDMMC_INT_RESP_ERR)
-		cmd->error = -EIO;
-	else
-		cmd->error = 0;
-
-	if (cmd->error) {
-		dev_vdbg(&host->pdev->dev,
-			"command error: status=0x%08x resp=0x%08x\n"
-			"cmd=0x%08x arg=0x%08x flg=0x%08x err=%d\n", 
-			status, cmd->resp[0], 
-			cmd->opcode, cmd->arg, cmd->flags, cmd->error);
-
-		if (cmd->data) {
-			host->data = NULL;
-			lpc313x_mci_stop_dma(host);
-		}
-	} 
-}
-
-static void lpc313x_mci_tasklet_func(unsigned long priv)
-{
-	struct lpc313x_mci	*host = (struct lpc313x_mci *)priv;
-	struct mmc_request	*mrq = host->mrq;
-	struct mmc_data		*data = host->data;
-	struct mmc_command	*cmd = host->cmd;
-	enum lpc313x_mci_state	state = host->state;
-	enum lpc313x_mci_state	prev_state;
-	u32			status;
-
-	spin_lock(&host->lock);
-
-	state = host->state;
-#if 0
-	dev_vdbg(&host->pdev->dev,
-		"tasklet: state %u pending/completed/mask %lx/%lx/%x\n",
-		state, host->pending_events, host->completed_events,
-		mci_readl(host, IMR)); // check reg
-#endif
-	do {
-		prev_state = state;
-
-		switch (state) {
-		case STATE_IDLE:
-			break;
-
-		case STATE_SENDING_CMD:
-			if (!lpc313x_mci_test_and_clear_pending(host,
-						EVENT_CMD_COMPLETE))
-				break;
-
-			host->cmd = NULL;
-			lpc313x_mci_set_completed(host, EVENT_CMD_COMPLETE);
-			lpc313x_mci_command_complete(host, mrq->cmd);
-			if (!mrq->data || cmd->error) {
-				lpc313x_mci_request_end(host, host->mrq);
-				goto unlock;
-			}
-
-			prev_state = state = STATE_SENDING_DATA;
-			/* fall through */
-
-		case STATE_SENDING_DATA:
-			if (lpc313x_mci_test_and_clear_pending(host,
-						EVENT_DATA_ERROR)) {
-				lpc313x_mci_stop_dma(host);
-				if (data->stop)
-					send_stop_cmd(host, data);
-				state = STATE_DATA_ERROR;
-				break;
-			}
-
-			if (!lpc313x_mci_test_and_clear_pending(host,
-						EVENT_XFER_COMPLETE))
-				break;
-
-			lpc313x_mci_set_completed(host, EVENT_XFER_COMPLETE);
-			prev_state = state = STATE_DATA_BUSY;
-			/* fall through */
-
-		case STATE_DATA_BUSY:
-			if (!lpc313x_mci_test_and_clear_pending(host,
-						EVENT_DATA_COMPLETE))
-				break;
-
-			host->data = NULL;
-			lpc313x_mci_set_completed(host, EVENT_DATA_COMPLETE);
-			status = host->data_status;
-
-			if (unlikely(status & LPC313x_MCI_DATA_ERROR_FLAGS)) {
-				if (status & SDMMC_INT_DTO) {
-					dev_err(&host->pdev->dev,
-							"data timeout error\n");
-					data->error = -ETIMEDOUT;
-				} else if (status & SDMMC_INT_DCRC) {
-					dev_err(&host->pdev->dev,
-							"data CRC error\n");
-					data->error = -EILSEQ;
-				} else {
-					dev_err(&host->pdev->dev,
-						"data FIFO error (status=%08x)\n",
-						status);
-					data->error = -EIO;
-				}
-			}
-			else {
-				data->bytes_xfered = data->blocks * data->blksz;
-				data->error = 0;
-			}
-
-			if (!data->stop) {
-				lpc313x_mci_request_end(host, host->mrq);
-				goto unlock;
-			}
-
-			prev_state = state = STATE_SENDING_STOP;
-			if (!data->error)
-				send_stop_cmd(host, data);
-			/* fall through */
-
-		case STATE_SENDING_STOP:
-			if (!lpc313x_mci_test_and_clear_pending(host,
-						EVENT_CMD_COMPLETE))
-				break;
-
-			host->cmd = NULL;
-			lpc313x_mci_command_complete(host, mrq->stop);
-			lpc313x_mci_request_end(host, host->mrq);
-			goto unlock;
-		case STATE_DATA_ERROR:
-			if (!lpc313x_mci_test_and_clear_pending(host,
-						EVENT_XFER_COMPLETE))
-				break;
-
-			state = STATE_DATA_BUSY;
-			break;
-		}
-	} while (state != prev_state);
-
-	host->state = state;
-
-unlock:
-	spin_unlock(&host->lock);
-
-}
-
-
-
-inline static void lpc313x_mci_push_data(void *buf,int cnt)
-{
-    u32* pData = (u32*)buf;
-
-    if (cnt % 4 != 0) 
-	    printk("error not align 4\n");
-
-    cnt = cnt >> 2;
-    while (cnt > 0) {
-        SDMMC_DATA = *pData++ ;
-        cnt--;
-    }
-}
-
-inline static void lpc313x_mci_pull_data(void *buf,int cnt)
-{
-    u32* pData = (u32*)buf;
-
-    if (cnt % 4 != 0) 
-	    printk("error not align 4\n");
-    cnt = cnt >> 2;
-    while (cnt > 0) {
-        *pData++ = SDMMC_DATA;
-        cnt--;
-    }
-}
-
-static void lpc313x_mci_read_data_pio(struct lpc313x_mci *host)
-{
-	struct scatterlist	*sg = host->sg;
-	void			*buf = sg_virt(sg);
-	unsigned int		offset = host->pio_offset;
-	struct mmc_data		*data = host->data;
-	u32			status;
-	unsigned int		nbytes = 0,len,old_len,count =0;
-
-	do {
-		len = SDMMC_GET_FCNT(mci_readl(STATUS)) << 2;
-		if(count == 0) 
-			old_len = len;
-		if (likely(offset + len <= sg->length)) {
-			lpc313x_mci_pull_data((void *)(buf + offset),len);
-
-			offset += len;
-			nbytes += len;
-
-			if (offset == sg->length) {
-				flush_dcache_page(sg_page(sg));
-				host->sg = sg = sg_next(sg);
-				if (!sg)
-					goto done;
-				offset = 0;
-				buf = sg_virt(sg);
-			}
-		} else {
-			unsigned int remaining = sg->length - offset;
-			lpc313x_mci_pull_data((void *)(buf + offset),remaining);
-			nbytes += remaining;
-
-			flush_dcache_page(sg_page(sg));
-			host->sg = sg = sg_next(sg);
-			if (!sg)
-				goto done;
-			offset = len - remaining;
-			buf = sg_virt(sg);
-			lpc313x_mci_pull_data(buf,offset);
-			nbytes += offset;
-		}
-
-		status = mci_readl(MINTSTS);
-		mci_writel(RINTSTS,SDMMC_INT_RXDR); // clear RXDR interrupt
-		if (status & LPC313x_MCI_DATA_ERROR_FLAGS) {
-			host->data_status = status;
-			data->bytes_xfered += nbytes;
-			smp_wmb();
-			lpc313x_mci_set_pending(host, EVENT_DATA_ERROR);
-			tasklet_schedule(&host->tasklet);
-			return;
-		}
-		count ++;
-	} while (status & SDMMC_INT_RXDR); // if the RXDR is ready let read again
-	len = SDMMC_GET_FCNT(mci_readl(STATUS));
-	host->pio_offset = offset;
-	data->bytes_xfered += nbytes;
-	return;
-
-done:
-	data->bytes_xfered += nbytes;
-	smp_wmb();
-	lpc313x_mci_set_pending(host, EVENT_XFER_COMPLETE);
-}
-
-static void lpc313x_mci_write_data_pio(struct lpc313x_mci *host)
-{
-	struct scatterlist	*sg = host->sg;
-	void			*buf = sg_virt(sg);
-	unsigned int		offset = host->pio_offset;
-	struct mmc_data		*data = host->data;
-	u32			status;
-	unsigned int		nbytes = 0,len;
-
-	do {
-
-		len = SDMMC_FIFO_SZ - (SDMMC_GET_FCNT(mci_readl(STATUS)) << 2);
-		if (likely(offset + len <= sg->length)) {
-			lpc313x_mci_push_data((void *)(buf + offset),len);
-
-			offset += len;
-			nbytes += len;
-			if (offset == sg->length) {
-				host->sg = sg = sg_next(sg);
-				if (!sg)
-					goto done;
-
-				offset = 0;
-				buf = sg_virt(sg);
-			}
-		} else {
-			unsigned int remaining = sg->length - offset;
-
-			lpc313x_mci_push_data((void *)(buf + offset), remaining);
-			nbytes += remaining;
-
-			host->sg = sg = sg_next(sg);
-			if (!sg) {
-				goto done;
-			}
-
-			offset = len - remaining;
-			buf = sg_virt(sg);
-			lpc313x_mci_push_data((void *)buf, offset);
-			nbytes += offset;
-		}
-
-		status = mci_readl(MINTSTS);
-		mci_writel(RINTSTS,SDMMC_INT_TXDR); // clear RXDR interrupt
-		if (status & LPC313x_MCI_DATA_ERROR_FLAGS) {
-			host->data_status = status;
-			data->bytes_xfered += nbytes;
-			smp_wmb();
-			lpc313x_mci_set_pending(host, EVENT_DATA_ERROR);
-			tasklet_schedule(&host->tasklet);
-			return;
-		}
-	} while (status & SDMMC_INT_TXDR); // if TXDR, let write again
-
-	host->pio_offset = offset;
-	data->bytes_xfered += nbytes;
-
-	return;
-
-done:
-	data->bytes_xfered += nbytes;
-	smp_wmb();
-	lpc313x_mci_set_pending(host, EVENT_XFER_COMPLETE);
-}
-
-static void lpc313x_mci_cmd_interrupt(struct lpc313x_mci *host, u32 status)
-{
-	if(!host->cmd_status) 
-		host->cmd_status = status;
-
-	smp_wmb();
-	lpc313x_mci_set_pending(host, EVENT_CMD_COMPLETE);
-	tasklet_schedule(&host->tasklet);
-}
-
-static irqreturn_t lpc313x_mci_interrupt(int irq, void *dev_id)
-{
-	struct lpc313x_mci	*host = dev_id;
-	u32			status,  pending;
-	unsigned int		pass_count = 0;
-
-	spin_lock(&host->lock);
-	do {
-		status = mci_readl(RINTSTS);
-		pending = mci_readl(MINTSTS);// read only mask reg
-		if (!pending)
-			break;
-		if(pending & LPC313x_MCI_CMD_ERROR_FLAGS) {
-		    mci_writel(RINTSTS,LPC313x_MCI_CMD_ERROR_FLAGS);  //  clear interrupt
-		    host->cmd_status = status;
-		    smp_wmb();
-		    lpc313x_mci_set_pending(host, EVENT_CMD_COMPLETE);
-		    tasklet_schedule(&host->tasklet);
-		}
-
-		if (pending & LPC313x_MCI_DATA_ERROR_FLAGS) { // if there is an error, let report DATA_ERROR
-			mci_writel(RINTSTS,LPC313x_MCI_DATA_ERROR_FLAGS);  // clear interrupt
-			host->data_status = status;
-			smp_wmb();
-			lpc313x_mci_set_pending(host, EVENT_DATA_ERROR);
-			tasklet_schedule(&host->tasklet);
-		}
-
-
-		if(pending & SDMMC_INT_DATA_OVER) {
-		    mci_writel(RINTSTS,SDMMC_INT_DATA_OVER);  // clear interrupt
-		    if (!host->data_status)
-			host->data_status = status;
-		    smp_wmb();
-		    if(host->dir_status == LPC313x_MCI_RECV_STATUS) {
-			if(host->sg != NULL) 
-				lpc313x_mci_read_data_pio(host);
-		    }
-		    lpc313x_mci_set_pending(host, EVENT_DATA_COMPLETE);
-		    tasklet_schedule(&host->tasklet);
-		}
-
-		if (pending & SDMMC_INT_RXDR) {
-		    mci_writel(RINTSTS,SDMMC_INT_RXDR);  //  clear interrupt
-		    if(host->sg) 
-			    lpc313x_mci_read_data_pio(host);
-		}
-
-		if (pending & SDMMC_INT_TXDR) {
-		    mci_writel(RINTSTS,SDMMC_INT_TXDR);  //  clear interrupt
-		    if(host->sg) {
-			lpc313x_mci_write_data_pio(host);
-		    }
-		}
-
-		if (pending & SDMMC_INT_CMD_DONE) {
-		    mci_writel(RINTSTS,SDMMC_INT_CMD_DONE);  //  clear interrupt
-		    lpc313x_mci_cmd_interrupt(host, status);
-		}
-
-		if (pending & SDMMC_INT_SDIO) {
-		    mci_writel(RINTSTS,SDMMC_INT_SDIO);  //  clear interrupt
-		    mmc_signal_sdio_irq(host->cur_slot->mmc);
-		}
-	} while (pass_count++ < 5);
-	
-	spin_unlock(&host->lock);
-
-	return pass_count ? IRQ_HANDLED : IRQ_NONE;
-}
-
-/*
- *
- * MMC card detect thread, kicked off from detect interrupt, 1 timer per slot
- *
- */
-static void lpc313x_mci_detect_change(unsigned long slot_data)
-{
-	struct lpc313x_mci_slot *slot = (struct lpc313x_mci_slot *) slot_data;
-	struct lpc313x_mci *host;
-	struct mmc_request *mrq;
-	bool present;
-	bool present_old;
-
-	host = slot->host;
-	/*
-	 * lpc313x_mci_cleanup_slot() sets the ATMCI_SHUTDOWN flag before
-	 * freeing the interrupt. We must not re-enable the interrupt
-	 * if it has been freed, and if we're shutting down, it
-	 * doesn't really matter whether the card is present or not.
-	 */
-	smp_rmb();
-	if (test_bit(LPC313x_MMC_SHUTDOWN, &slot->flags))
-		return;
-
-	enable_irq(slot->irq);
-	present = !host->pdata->get_cd(slot->id);
-	present_old = test_bit(LPC313x_MMC_CARD_PRESENT, &slot->flags);
-	dev_vdbg(&slot->mmc->class_dev, "detect change: %d (was %d)\n",
-			present, present_old);
-
-	if (present != present_old) {
-
-		dev_info(&slot->mmc->class_dev, "card %s\n",
-			present ? "inserted" : "removed");
-
-		spin_lock(&host->lock);
-
-		/* Power up slot */
-		if (present != 0) {
-			if (host->pdata->setpower)
-				host->pdata->setpower(slot->id, slot->mmc->ocr_avail);
-
-			set_bit(LPC313x_MMC_CARD_PRESENT, &slot->flags);
-		} else {
-			if (host->pdata->setpower)
-				host->pdata->setpower(slot->id, 0);
-
-			clear_bit(LPC313x_MMC_CARD_PRESENT, &slot->flags);
-		}			
-
-
-		/* Clean up queue if present */
-		mrq = slot->mrq;
-		if (mrq) {
-			if (mrq == host->mrq) {
-			  	/* reset all blocks */
-			  	mci_writel(CTRL,(SDMMC_CTRL_RESET | SDMMC_CTRL_FIFO_RESET | SDMMC_CTRL_DMA_RESET));
-			  	/* wait till resets clear */
-			  	while (mci_readl(CTRL) & (SDMMC_CTRL_RESET | SDMMC_CTRL_FIFO_RESET | SDMMC_CTRL_DMA_RESET));
-
-				host->data = NULL;
-				host->cmd = NULL;
-
-				switch (host->state) {
-				case STATE_IDLE:
-					break;
-				case STATE_SENDING_CMD:
-					mrq->cmd->error = -ENOMEDIUM;
-					if (!mrq->data)
-						break;
-					/* fall through */
-				case STATE_SENDING_DATA:
-					mrq->data->error = -ENOMEDIUM;
-					lpc313x_mci_stop_dma(host);
-					break;
-				case STATE_DATA_BUSY:
-				case STATE_DATA_ERROR:
-					if (mrq->data->error == -EINPROGRESS)
-						mrq->data->error = -ENOMEDIUM;
-					if (!mrq->stop)
-						break;
-					/* fall through */
-				case STATE_SENDING_STOP:
-					mrq->stop->error = -ENOMEDIUM;
-					break;
-				}
-
-				lpc313x_mci_request_end(host, mrq);
-			} else {
-				list_del(&slot->queue_node);
-				mrq->cmd->error = -ENOMEDIUM;
-				if (mrq->data)
-					mrq->data->error = -ENOMEDIUM;
-				if (mrq->stop)
-					mrq->stop->error = -ENOMEDIUM;
-
-				spin_unlock(&host->lock);
-				mmc_request_done(slot->mmc, mrq);
-				spin_lock(&host->lock);
-			}
-
-		}
-
-		spin_unlock(&host->lock);
-		mmc_detect_change(slot->mmc, 0);
-	}
-}
-
-static irqreturn_t lpc313x_mci_detect_interrupt(int irq, void *dev_id)
-{
-	struct lpc313x_mci_slot	*slot = dev_id;
-
-	/*
-	 * Disable interrupts until the pin has stabilized and check
-	 * the state then. Use mod_timer() since we may be in the
-	 * middle of the timer routine when this interrupt triggers.
-	 */
-	disable_irq_nosync(irq);
-	mod_timer(&slot->detect_timer, jiffies + msecs_to_jiffies(20));
-
-	return IRQ_HANDLED;
-}
-
-static int __init
-lpc313x_mci_init_slot(struct lpc313x_mci *host, unsigned int id)
-{
-	struct mmc_host			*mmc;
-	struct lpc313x_mci_slot		*slot;
-
-	mmc = mmc_alloc_host(sizeof(struct lpc313x_mci_slot), &host->pdev->dev);
-
-	if (!mmc)
-		return -ENOMEM;
-
-	slot = mmc_priv(mmc);
-	slot->id = id;
-	slot->mmc = mmc;
-	slot->host = host;
-
-	mmc->ops = &lpc313x_mci_ops;
-	mmc->f_min = DIV_ROUND_UP(host->bus_hz, 510);
-	mmc->f_max = host->bus_hz/2; //max f is clock to mmc_clk/2
-	if (host->pdata->get_ocr)
-		mmc->ocr_avail = host->pdata->get_ocr(id);
-	else
-		mmc->ocr_avail = MMC_VDD_32_33 | MMC_VDD_33_34;
-
-	/* Start with slot power disabled, will be enabled when card is detected */
-	if (host->pdata->setpower)
-		host->pdata->setpower(id, 0);
-
-	mmc->caps = MMC_CAP_SDIO_IRQ;
-	if (host->pdata->get_bus_wd)
-		if (host->pdata->get_bus_wd(slot->id) >= 4)
-			mmc->caps |= MMC_CAP_4_BIT_DATA;
-
-	mmc->max_phys_segs = 64;
-	mmc->max_hw_segs = 64;
-	mmc->max_blk_size = 65536; /* BLKSIZ is 16 bits*/
-	mmc->max_blk_count = 512;
-	mmc->max_req_size = mmc->max_blk_size * mmc->max_blk_count;
-	mmc->max_seg_size = mmc->max_req_size;
-
-	/* call board init */
-	slot->irq = host->pdata->init(id, lpc313x_mci_detect_interrupt, slot);
-	/* Assume card is present initially */
-	if(!host->pdata->get_cd(id))
-		set_bit(LPC313x_MMC_CARD_PRESENT, &slot->flags);
-	else
-		clear_bit(LPC313x_MMC_CARD_PRESENT, &slot->flags);
-
-	host->slot[id] = slot;
-	mmc_add_host(mmc);
-
-
-#if defined (CONFIG_DEBUG_FS)
-	lpc313x_mci_init_debugfs(slot);
-#endif
-
-	/* Create card detect handler thread for the slot */
-	setup_timer(&slot->detect_timer, lpc313x_mci_detect_change,
-			(unsigned long)slot);
-
-	return 0;
-}
-
-static void lpc313x_mci_cleanup_slot(struct lpc313x_mci_slot *slot,
-		unsigned int id)
-{
-	/* Shutdown detect IRQ and kill detect thread */
-	if (slot->host->pdata->exit)
-		slot->host->pdata->exit(id);
-	del_timer_sync(&slot->detect_timer);
-
-	/* Debugfs stuff is cleaned up by mmc core */
-	set_bit(LPC313x_MMC_SHUTDOWN, &slot->flags);
-	smp_wmb();
-	mmc_remove_host(slot->mmc);
-	slot->host->slot[id] = NULL;
-	mmc_free_host(slot->mmc);
-}
-
-
-static int lpc313x_mci_probe(struct platform_device *pdev)
-{
-	struct lpc313x_mci		*host;
-	struct resource			*regs;
-	struct lpc313x_mci_board	*pdata;
-	int				irq;
-	int				ret = 0;
-	int i;
-
-	regs = platform_get_resource(pdev, IORESOURCE_MEM, 0);
-	if (!regs)
-		return -ENXIO;
-
-
-	irq = platform_get_irq(pdev, 0);
-	if (irq < 0)
-		return irq;
-
-	host = kzalloc(sizeof(struct lpc313x_mci), GFP_KERNEL);
-	if (!host)
-		return -ENOMEM;
-
-	host->pdev = pdev;
-	host->pdata = pdata = pdev->dev.platform_data;
-	if (!pdata) {
-		dev_err(&pdev->dev, "Platform data missing\n");
-		ret = -ENODEV;
-		goto err_freehost;
-	}
-
-	if (((pdata->num_slots > 1) && !(pdata->select_slot)) ||
-	     !(pdata->get_ro) || !(pdata->get_cd) || !(pdata->init)) {
-		dev_err(&pdev->dev, "Platform data wrong\n");
-		ret = -ENODEV;
-		goto err_freehost;
-	}
-
-	spin_lock_init(&host->lock);
-	INIT_LIST_HEAD(&host->queue);
-
-	ret = -ENOMEM;
-	host->regs = ioremap(regs->start, regs->end - regs->start);
-	if (!host->regs)
-	    goto err_freehost;
-
-	/* enable the clock to MCI module */
-	cgu_clk_en_dis(CGU_SB_SD_MMC_HCLK_ID, 1);
-	cgu_clk_en_dis(CGU_SB_SD_MMC_CCLK_IN_ID, 1);
-
-	/* reset SD/MMC/MCI modules through CGU */
-	/* clear and set the register */
-	CGU_CFG->resetn_soft[SD_MMC_PNRES_SOFT] = 0;
-	CGU_CFG->resetn_soft[SD_MMC_NRES_CCLK_IN_SOFT] = 0;
-	/* introduce some delay */
-	udelay(1);
-	CGU_CFG->resetn_soft[SD_MMC_NRES_CCLK_IN_SOFT] = CGU_CONFIG_SOFT_RESET;
-	CGU_CFG->resetn_soft[SD_MMC_PNRES_SOFT] = CGU_CONFIG_SOFT_RESET;
-
-#ifdef USE_DMA
-	host->dma_chn = dma_request_sg_channel("MCI",  lpc313x_mci_dma_complete, host, 1);
-	host->sg_cpu = dma_alloc_coherent(&pdev->dev, PAGE_SIZE, &host->sg_dma, GFP_KERNEL);
-	if (host->sg_cpu == NULL) {
-		dev_err(&pdev->dev,
-			 "%s: could not alloc dma memory \n", __func__);
-		goto err_freemap;
-	}
-#endif
-	host->bus_hz = cgu_get_clk_freq(CGU_SB_SD_MMC_CCLK_IN_ID); //40000000;
-
-	/* Set IOCONF to MCI pins */
-	SYS_SDMMC_DELAYMODES = 0;
-	SYS_MUX_GPIO_MCI = 1;
-
-	/* set the pins as driven by IP in IOCONF */
-	GPIO_DRV_IP(IOCONF_EBI_MCI, 0xF0000003);
-
-	/* set delay gates */
-	SYS_SDMMC_DELAYMODES = 0x1B;
-
-  	/* reset all blocks */
-  	mci_writel(CTRL,(SDMMC_CTRL_RESET | SDMMC_CTRL_FIFO_RESET | SDMMC_CTRL_DMA_RESET));
-  	/* wait till resets clear */
-  	while (mci_readl(CTRL) & (SDMMC_CTRL_RESET | SDMMC_CTRL_FIFO_RESET | SDMMC_CTRL_DMA_RESET));
-
-	 /* Clear the interrupts for the host controller */
-	mci_writel(RINTSTS, 0xFFFFFFFF);
-	mci_writel(INTMASK, 0); // disable all mmc interrupt first
-
-  	/* Put in max timeout */
-  	mci_writel(TMOUT, 0xFFFFFFFF);
-
-  	/* FIFO threshold settings  */
-#ifdef BURST_DMA
-	mci_writel(FIFOTH, ((0x1 << 28) | (0xB << 16) | (0xC << 0))); // RXMark = 11, TXMark = 12, DMA Size = 4
-#else
-  	mci_writel(FIFOTH, ((0x2 << 28) | (0x10 << 16) | (0x10 << 0))); // RXMark = 16, TXMark = 16, DMA Size = 8
-#endif
-
-	/* disable clock to CIU */
-	mci_writel(CLKENA,0);
-	mci_writel(CLKSRC,0);
-
-	tasklet_init(&host->tasklet, lpc313x_mci_tasklet_func, (unsigned long)host);
-	ret = request_irq(irq, lpc313x_mci_interrupt, 0, dev_name(&pdev->dev), host);
-	if (ret)
-	    goto err_dmaunmap;
-
-	platform_set_drvdata(pdev, host);
-
-	/* We need at least one slot to succeed ####pd####*/
-	for (i = 0; i < host->pdata->num_slots; i++) {
-		ret = lpc313x_mci_init_slot(host, i);
-		if (ret) {
-		    ret = -ENODEV;
-		    goto err_init_slot;
-		}
-	}
-
-	// enable interrupt for command done, data over, data empty, receive ready and error such as transmit, receive timeout, crc error
-	mci_writel(RINTSTS, 0xFFFFFFFF);
-	mci_writel(INTMASK,SDMMC_INT_CMD_DONE | SDMMC_INT_DATA_OVER | SDMMC_INT_TXDR | SDMMC_INT_RXDR | LPC313x_MCI_ERROR_FLAGS);
-	mci_writel(CTRL,SDMMC_CTRL_INT_ENABLE); // enable mci interrupt
-
-
-	dev_info(&pdev->dev, "LPC313x MMC controller at irq %d\n", irq);
-
-	return 0;
-
-err_init_slot:
-	/* De-init any initialized slots */
-	while (i > 0) {
-		if (host->slot[i])
-			lpc313x_mci_cleanup_slot(host->slot[i], i);
-		i--;
-	}
-	free_irq(irq, host);
-err_dmaunmap:
-#ifdef USE_DMA
-	dma_free_coherent(&pdev->dev, PAGE_SIZE, host->sg_cpu, host->sg_dma);
-	dma_release_sg_channel(host->dma_chn);
-err_freemap:
-#endif
-	iounmap(host->regs);
-err_freehost:
-	kfree(host);
-	return ret;
-}
-
-
-
-static int __exit lpc313x_mci_remove(struct platform_device *pdev)
-{
-	struct lpc313x_mci *host = platform_get_drvdata(pdev);
-	int i;
-
-	mci_writel(RINTSTS, 0xFFFFFFFF);
-	mci_writel(INTMASK, 0); // disable all mmc interrupt first
-
-	platform_set_drvdata(pdev, NULL);
-
-	for (i = 0; i < host->pdata->num_slots; i++) {
-		dev_dbg(&pdev->dev, "remove slot %d\n", i);
-		if (host->slot[i])
-			lpc313x_mci_cleanup_slot(host->slot[i], i);
-	}
-
-	/* disable clock to CIU */
-	mci_writel(CLKENA,0);
-	mci_writel(CLKSRC,0);
-
-	/*  turn off the mci clock here */
-	cgu_clk_en_dis(CGU_SB_SD_MMC_HCLK_ID, 0);
-	cgu_clk_en_dis(CGU_SB_SD_MMC_CCLK_IN_ID, 0);
-
-	free_irq(platform_get_irq(pdev, 0), host);
-#ifdef USE_DMA
-	dma_free_coherent(&pdev->dev, PAGE_SIZE, host->sg_cpu, host->sg_dma);
-	dma_release_sg_channel(host->dma_chn);
-#endif
-	iounmap(host->regs);
-
-	kfree(host);
-	return 0;
-}
-
-static int lpc313x_mci_suspend(struct platform_device *pdev, pm_message_t state)
-{
-#ifdef CONFIG_PM
-	/* Disable Card clock */
-	mci_writel(CLKENA,0);
-
-	/* Disable IP clocks */
-	cgu_clk_en_dis(CGU_SB_SD_MMC_HCLK_ID, 0);
-	cgu_clk_en_dis(CGU_SB_SD_MMC_CCLK_IN_ID, 0);
-#endif
-	return 0;
-}
-
-static int lpc313x_mci_resume(struct platform_device *pdev)
-{
-#ifdef CONFIG_PM
-	/* Enable IP Clocks */
-	cgu_clk_en_dis(CGU_SB_SD_MMC_HCLK_ID, 1);
-	cgu_clk_en_dis(CGU_SB_SD_MMC_CCLK_IN_ID, 1);
-
-	/* Enable Card clock */
-	mci_writel(CLKENA ,SDMMC_CLKEN_ENABLE);
-#endif
-	return 0;
-}
-
-static struct platform_driver lpc313x_mci_driver = {
-	.suspend    = lpc313x_mci_suspend,
-	.resume     = lpc313x_mci_resume,
-	.remove		= __exit_p(lpc313x_mci_remove),
-	.driver		= {
-		.name		= "lpc313x_mmc",
-	},
-};
-
-static int __init lpc313x_mci_init(void)
-{
-	return platform_driver_probe(&lpc313x_mci_driver, lpc313x_mci_probe);
-}
-
-static void __exit lpc313x_mci_exit(void)
-{
-	platform_driver_unregister(&lpc313x_mci_driver);
-}
-
-module_init(lpc313x_mci_init);
-module_exit(lpc313x_mci_exit);
-
-MODULE_DESCRIPTION("LPC313x Multimedia Card Interface driver");
-MODULE_AUTHOR("NXP Semiconductor VietNam");
-MODULE_LICENSE("GPL v2");
diff --exclude CVS --exclude .git -uNr linux-2.6.33/drivers/mtd/nand/lpc313x_nand.c~ linux-2.6.33.modified/drivers/mtd/nand/lpc313x_nand.c~
--- linux-2.6.33/drivers/mtd/nand/lpc313x_nand.c~	2012-10-01 21:38:07.433088477 -0700
+++ linux-2.6.33.modified/drivers/mtd/nand/lpc313x_nand.c~	1969-12-31 16:00:00.000000000 -0800
@@ -1,1582 +0,0 @@
-/*
- * LPC313x NAND Controller Interface driver
- *
- * drivers/mtd/nand/lpc313x_nand.c
- *
- * Copyright (C) 2009 NXP Semiconductors
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- *
- * TODO
- * Verify BB check code - I don't think it's working for all device sizes
- * Huge block support may not work due to kernel limitations
- */
-
-#include <linux/module.h>
-#include <linux/types.h>
-#include <linux/init.h>
-#include <linux/kernel.h>
-#include <linux/string.h>
-#include <linux/ioport.h>
-#include <linux/platform_device.h>
-#include <linux/delay.h>
-#include <linux/err.h>
-#include <linux/slab.h>
-#include <linux/clk.h>
-#include <linux/cpufreq.h>
-#include <linux/dma-mapping.h>
-
-#include <linux/mtd/mtd.h>
-#include <linux/mtd/nand.h>
-#include <linux/mtd/nand_ecc.h>
-#include <linux/mtd/partitions.h>
-
-#include <asm/io.h>
-
-#include <mach/irqs.h>
-#include <mach/registers.h>
-#include <linux/mmc/host.h>
-#include <mach/gpio.h>
-#include <mach/cgu.h>
-#include <mach/board.h>
-/* for time being use arch specific DMA framework
- * instead of generic framework
- * */
-#include <mach/dma.h>
-
-/*  Enable DMA transfer for better throughput (only when EEC is enabled)
- * */
-#ifdef CONFIG_HARDWARE_ECC
-#define USE_DMA
-#define NAND_DMA_MAX_DESC 4  /* Maximum number of DMA descritpors in SG table */
-#define OOB_FREE_OFFSET 4
-#endif
-
-
-/* Register access macros */
-#define nand_readl(reg)		__raw_readl(&NAND_##reg)
-#define nand_writel(reg,value)	__raw_writel((value),&NAND_##reg)
-#define sys_writel(reg,value)	__raw_writel((value),&SYS_##reg)
-
-
-/* Enable for polling support only. Polling support will compile the
-   code without interrupts during read and write cycles. Device ready
-   status, buffer status, and ECC status are all polled. This may give
-   a slight performance improvement at the expense of CPU usage. For
-   very slow NAND devices, you wouldn't want to use polling. */
-//#define STATUS_POLLING
-
-/* Huge block support not working in 2.6.28.2 kernel, don't use this! */
-//#define HUGE_BLOCK_SUPPORT
-
-/* Device specific MTD structure, 1 per chip select */
-struct lpc313x_nand_mtd {
-	struct mtd_info mtd;
-	struct nand_chip chip;
-	struct lpc313x_nand_info *host;
-};
-
-/* Local driver data structure */
-struct lpc313x_nand_info {
-	struct nand_hw_control controller;
-	struct lpc313x_nand_cfg *platform;
-	struct lpc313x_nand_mtd *mtds;
-	struct device *dev;
-	u32 nandconfig;
-	int current_cs;
-#ifdef USE_DMA
-	int	dma_chn;
-	dma_addr_t sg_dma;
-	dma_sg_ll_t *sg_cpu;
-	wait_queue_head_t dma_waitq;
-	volatile u32 dmapending;
-#endif
-	int irq;
-	wait_queue_head_t irq_waitq;
-	volatile u32 intspending;
-};
-
-/* Chip select specific ready check masks */
-static const int rdymasks[4] = {
-	NAND_NANDCHECKSTS_RB1_LVL,
-	NAND_NANDCHECKSTS_RB2_LVL,
-	NAND_NANDCHECKSTS_RB3_LVL,
-	NAND_NANDCHECKSTS_RB4_LVL
-};
-
-/* Decode and encode buffer ECC status masks */
-static const u32 nand_buff_dec_mask[2] = {
-	NAND_NANDIRQSTATUS1_ECC_DEC_RAM0, NAND_NANDIRQSTATUS1_ECC_DEC_RAM1};
-static const u32 nand_buff_enc_mask[2] = {
-	NAND_NANDIRQSTATUS1_ECC_ENC_RAM0, NAND_NANDIRQSTATUS1_ECC_ENC_RAM1};
-static const u32 nand_buff_wr_mask[2] = {NAND_NANDIRQSTATUS1_WR_RAM0,
-	NAND_NANDIRQSTATUS1_WR_RAM1};
-
-#ifdef CONFIG_HARDWARE_ECC
-/* Decode buffer addresses */
-static const void *nand_buff_addr[2] = {
-	(void *) &NAND_BUFFER_ADRESS, (void *) (&NAND_BUFFER_ADRESS + 256)};
-
-#ifdef USE_DMA
-/* Decode buffer physical addresses */
-static const u32 nand_buff_phys_addr[2] = {
-	IO_NAND_BUF_PHYS, (IO_NAND_BUF_PHYS + 0x400)};
-#endif
-
-/*
- *
- * OOB data placement structures for small/large/huge block FLASH
- *
- */
-
-/*
- * Autoplacement pattern for 512+16 bytes small block NAND FLASH
- */
-static struct nand_ecclayout nand_hw_eccoob_16 = {
-	.eccbytes	= 12,
-	.eccpos		= {
-				4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15
-			  },
-	.oobfree	= {
-				{0, 4},
-			  }
-};
-
-/*
- * Autoplacement pattern for 2048+64 bytes large block NAND FLASH
- */
-static struct nand_ecclayout nand_hw_eccoob_64 = {
-	.eccbytes	= 48,
-	.eccpos		= {
-				4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
-				20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31,
-				36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,
-				52, 53, 54, 55, 56, 67, 58, 59, 60, 61, 62, 63
-			  },
-	.oobfree	= {
-				{0, 4},
-				{16, 4},
-				{32, 4},
-				{48, 4}
-			  }
-};
-
-#ifdef HUGE_BLOCK_SUPPORT
-/*
- * Autoplacement pattern for 4096+128 bytes large block NAND FLASH
- */
-static struct nand_ecclayout nand_hw_eccoob_128 = {
-	.eccbytes	= 96,
-	.eccpos		= {
-				4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
-				20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31,
-				36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,
-				52, 53, 54, 55, 56, 67, 58, 59, 60, 61, 62, 63,
-				68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,
-				84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95,
-				100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111,
-				116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127
-			  },
-	.oobfree	= {
-				{0, 4},
-				{16, 4},
-				{32, 4},
-				{48, 4},
-				{64, 4},
-				{80, 4},
-				{96, 4},
-				{112, 4}
-			  }
-};
-#endif
-
-// Dummy bytes for bad block ( just for HARDWARE ECC: inaccurate )
-static uint8_t scan_ff_pattern[] = { 0xff, 0xff };
-
-static struct nand_bbt_descr lpc313x_largepage_flashbased = {
-	.options = NAND_BBT_SCAN2NDPAGE,
-	.offs = 50,
-	.len = 2,
-	.pattern = scan_ff_pattern
-};
-#endif  //CONFIG_HARDWARE_ECC
-
-/*
- *
- * Bad block descriptors for small/large/huge block FLASH
- *
- */
-/*
- *	hardware specific flash bbt decriptors
- */
-static uint8_t bbt_pattern[] = { 'B', 'b', 't', '0' };
-static uint8_t mirror_pattern[] = { '1', 't', 'b', 'B' };
-
-static struct nand_bbt_descr lpc313x_bbt_main_descr = {
-	.options = NAND_BBT_LASTBLOCK | NAND_BBT_CREATE | NAND_BBT_WRITE
-		| NAND_BBT_2BIT | NAND_BBT_VERSION | NAND_BBT_PERCHIP,
-	.offs = 32,
-	.len = 4,
-	.veroffs = 48,
-	.maxblocks = 4,
-	.pattern = bbt_pattern
-};
-
-static struct nand_bbt_descr lpc313x_bbt_mirror_descr = {
-	.options = NAND_BBT_LASTBLOCK | NAND_BBT_CREATE | NAND_BBT_WRITE
-		| NAND_BBT_2BIT | NAND_BBT_VERSION | NAND_BBT_PERCHIP,
-	.offs = 32,
-	.len = 4,
-	.veroffs = 48,
-	.maxblocks = 4,
-	.pattern = mirror_pattern
-};
-
-
-#ifdef USE_DMA
-/*
- * DMA transfer callback function
- * @ chn: Channel number
- * @ type: Interrupt type
- * @ arg: Function argument
- */
-static void lpc313x_nand_dma_irq(int chn, dma_irq_type_t type,
-		void *arg)
-{
-	struct lpc313x_nand_info *host = (struct lpc313x_nand_info *)arg;
-
-	/* SG Table ended */
-	if (type == DMA_IRQ_FINISHED)
-	{
-		/* Flag event and wakeup */
-		host->dmapending = 1;
-		wake_up(&host->dma_waitq);
-	}
-	else if (type == DMA_IRQS_ABORT)
-	{
-		/* DMA data abort - this might not be a
-		   error for this channel. Ignore */
-	}
-
-	return;
-}
-
-/*
- * DMA mapping function
- * host : Pointer to ilpc313x_nand_info structure
- * addr : Address to be DMA mapped
- * size : Size of the buffer
- * rd : DMA direction (1: read operation, 0: Write operation
- */
-static dma_addr_t lpc313x_nand_dma_map(struct lpc313x_nand_info *host,
-		u32 addr, u32 size, int rd)
-{
-	void *addr_map;
-	dma_addr_t dma_addr;
-	enum dma_data_direction dir = rd ? DMA_FROM_DEVICE :
-								DMA_TO_DEVICE;
-
-	if ((void *)addr >= high_memory) {
-		/* For vmalloced buffers, check if buffer is within PAGE_SIZE.
-	 	* If buffer is not within PAGE_SIZE, DMA map will not work
-		* If buffer not within PAGE_SIZE, return with 0 (mapping failed)
-		* Else DMA map the buffer.
-	 	* */
-		struct page *p1;
-
-		if (((size_t)addr & PAGE_MASK) !=
-				((size_t)(addr + size - 1) & PAGE_MASK)) {
-			dev_err(host->dev, "Buffer not within page \r\n");
-			return 0;
-		}
-
-		/* Get page address address */
-		p1 = vmalloc_to_page((void *)addr);
-		if (!p1) {
-			dev_err(host->dev, "vmalloc_to_page failure \r\n");
-			return 0;
-		}
-		addr_map = page_address(p1) + ((size_t)addr & ~PAGE_MASK);
-	}
-	else {
-		/* kmalloced buffer */
-		addr_map = (void *)addr;
-	}
-
-	/* Get DMA mapping */
-	dma_addr = (u32) dma_map_single(host->dev, (void *) addr_map,
-				size, dir);
-	if (dma_mapping_error(host->dev, dma_addr))
-	{
-		dev_err(host->dev, "DMA mapping failure \r\n");
-		return 0;
-	}
-
-	return dma_addr;
-}
-
-/*
- * DMA Scatter Gather transfer function
- * mtd : Pointer to mtd_info structure
- * chip : Pointer to nand_chip structure
- * bufrdy : SRAM buffer index
- * pay_load : Pay load buffer physical address
- * oob_data : OOB data buffer physical address
- * rd : read flag (1: read operation 0: write operation)
- */
-static void lpc313x_nand_dma_sg_tfr(struct mtd_info *mtd,
-		struct nand_chip *chip, int bufrdy,	u32 pay_load, u32 oob_data, int rd)
-{
-	struct lpc313x_nand_mtd *nmtd;
-	struct lpc313x_nand_info *host;
-	int eccsize = chip->ecc.size;
-	int oob_size = rd ? chip->ecc.bytes : OOB_FREE_OFFSET;
-
-	nmtd = chip->priv;
-	host = nmtd->host;
-
-	/* SG entry to transfer pay load */
-	host->sg_cpu[0].setup.src_address = rd ? nand_buff_phys_addr[bufrdy] :
-			pay_load;
-	host->sg_cpu[0].setup.dest_address = rd ? pay_load :
-			nand_buff_phys_addr[bufrdy];
-	host->sg_cpu[0].setup.trans_length = (eccsize >> 2) - 1;
-	host->sg_cpu[0].setup.cfg = DMA_CFG_CMP_CH_EN |
-			DMA_CFG_CMP_CH_NR(host->dma_chn) | DMA_CFG_TX_WORD;
-	host->sg_cpu[0].next_entry = host->sg_dma + sizeof(dma_sg_ll_t);
-
-	/* SG entry to transfer OOB data */
-	host->sg_cpu[1].setup.src_address = rd ? (nand_buff_phys_addr[bufrdy] +
-			eccsize) : oob_data;
-	host->sg_cpu[1].setup.dest_address = rd ? oob_data :
-			(nand_buff_phys_addr[bufrdy] + eccsize);
-	host->sg_cpu[1].setup.trans_length = (oob_size >> 2) - 1;
-	host->sg_cpu[1].setup.cfg = DMA_CFG_TX_WORD;
-	host->sg_cpu[1].next_entry = 0;
-
-	/* Program the SG channel */
-	dma_prog_sg_channel(host->dma_chn, host->sg_dma);
-
-	/* Enable FINISHED interrupt */
-	dma_set_irq_mask(host->dma_chn, 1, 0);
-	dma_set_irq_mask((host->dma_chn - 1), 1, 0);
-
-	/* Set counter to 0 */
-	dma_write_counter((host->dma_chn - 1), 0);
-
-	/* Start the transfer */
-	host->dmapending = 0;
-	dma_start_channel(host->dma_chn);
-
-	/* Wait for FINISHED interrupt */
-	wait_event(host->dma_waitq, host->dmapending);
-
-	/* Mask all the interrupts for the channel */
-	dma_set_irq_mask(host->dma_chn, 1, 1);
-	dma_set_irq_mask((host->dma_chn - 1), 1, 1);
-
-	/* Stop the channel */
-	dma_stop_channel(host->dma_chn);
-
-	return;
-}
-#endif
-
-/*
- *
- * NAND controller hardware support functions
- *
- */
-
-/* Enable or disable NAND controller clocks */
-static void lpc313x_nand_clocks_disen(int en) {
-	/* Enable or disable clocks for NAND Controller */
-	cgu_clk_en_dis(CGU_SB_NANDFLASH_S0_CLK_ID, en);
-	cgu_clk_en_dis(CGU_SB_NANDFLASH_ECC_CLK_ID, en);
-	cgu_clk_en_dis(CGU_SB_NANDFLASH_NAND_CLK_ID, en);
-	cgu_clk_en_dis(CGU_SB_NANDFLASH_PCLK_ID, en);
-
-	/* Needed for LPC3143/54 chips only */
-	cgu_clk_en_dis(CGU_SB_NANDFLASH_AES_CLK_ID, en);
-}
-
-/*
- * Setup NAND interface timing
- */
-static void lpc313x_nand_setrate(struct lpc313x_nand_timing *timing) {
-	u32 tmp, timing1, timing2, srcclk;
-
-	/* Get the NAND controller base clock rate */
-	srcclk = cgu_get_clk_freq(CGU_SB_NANDFLASH_NAND_CLK_ID);
-
-	/* Compute number of clocks for timing1 parameters */
-	tmp = srcclk / (1000000000 / timing->ns_trsd);
-	if (tmp > 0x3)
-		tmp = 0x3;
-	timing1 = NAND_NANDTIMING1_TSRD(tmp);
-	tmp = srcclk / (1000000000 / timing->ns_tals);
-	if (tmp > 0x7)
-		tmp = 0x7;
-	timing1 |= NAND_NANDTIMING1_TALS(tmp);
-	tmp = srcclk / (1000000000 / timing->ns_talh);
-	if (tmp > 0x7)
-		tmp = 0x7;
-	timing1 |= NAND_NANDTIMING1_TALH(tmp);
-	tmp = srcclk / (1000000000 / timing->ns_tcls);
-	if (tmp > 0x7)
-		tmp = 0x7;
-	timing1 |= NAND_NANDTIMING1_TCLS(tmp);
-	tmp = srcclk / (1000000000 / timing->ns_tclh);
-	if (tmp > 0x7)
-		tmp = 0x7;
-	timing1 |= NAND_NANDTIMING1_TCLH(tmp);
-	nand_writel(TIMING1, timing1);
-
-
-	/* Compute number of clocks for timing2 parameters */
-	tmp = srcclk / (1000000000 / timing->ns_tdrd);
-	if (tmp > 0x3)
-		tmp = 0x3;
-	timing2 = NAND_NANDTIMING2_TDRD(tmp);
-	tmp = srcclk / (1000000000 / timing->ns_tebidel);
-	if (tmp > 0x7)
-		tmp = 0x7;
-	timing2 |= NAND_NANDTIMING2_TEBI(tmp);
-	tmp = srcclk / (1000000000 / timing->ns_tch);
-	if (tmp > 0x7)
-		tmp = 0x7;
-	timing2 |= NAND_NANDTIMING2_TCH(tmp);
-	tmp = srcclk / (1000000000 / timing->ns_tcs);
-	if (tmp > 0x7)
-		tmp = 0x7;
-	timing2 |= NAND_NANDTIMING2_TCS(tmp);
-	tmp = srcclk / (1000000000 / timing->ns_treh);
-	if (tmp > 0x7)
-		tmp = 0x7;
-	timing2 |= NAND_NANDTIMING2_TRH(tmp);
-	tmp = srcclk / (1000000000 / timing->ns_trp);
-	if (tmp > 0x7)
-		tmp = 0x7;
-	timing2 |= NAND_NANDTIMING2_TRP(tmp);
-	tmp = srcclk / (1000000000 / timing->ns_trw);
-	if (tmp > 0x7)
-		tmp = 0x7;
-	timing2 |= NAND_NANDTIMING2_TWH(tmp);
-	tmp = srcclk / (1000000000 / timing->ns_twp);
-	if (tmp > 0x7)
-		tmp = 0x7;
-	timing2 |= NAND_NANDTIMING2_TWP(tmp);
-	nand_writel(TIMING2, timing2);
-}
-
-/*
- * Initialize the NAND interface
- */
-static int lpc313x_nand_inithw(struct lpc313x_nand_info *host) {
-	unsigned long reg;
-
-	/* Disable all NAND interrupts */
-	nand_writel(IRQMASK1, ~0);
-	nand_writel(IRQMASK2, ~0);
-
-	/* Setup device and controller timing */
-	lpc313x_nand_setrate(host->platform->timing);
-
-	/* enable the controller and de-assert nFCE */
-	reg = nand_readl(CONFIG) | host->nandconfig;
-	nand_writel(CONFIG, reg);
-
-	return 0;
-}
-
-/*
- * Enable NAND interrupts
- */
-static inline void lpc313x_nand_int_en(u32 mask) {
-#if !defined(STATUS_POLLING)
-	u32 tmp = nand_readl(IRQMASK1) & ~mask;
-
-	nand_writel(IRQMASK1, tmp);
-#endif
-}
-
-/*
- * Disable NAND interrupts
- */
-static inline void lpc313x_nand_int_dis(u32 mask) {
-#if !defined(STATUS_POLLING)
-	u32 tmp = nand_readl(IRQMASK1) | mask;
-
-	nand_writel(IRQMASK1, tmp);
-#endif
-}
-
-/*
- * Clear NAND interrupts
- */
-static inline void lpc313x_nand_int_clear(u32 mask) {
-	nand_writel(IRQSTATUSRAW1, mask);
-}
-
-/*
- * Return pending NAND interrupts status
- */
-static inline u32 lpc313x_nand_int_get(void) {
-	return nand_readl(IRQSTATUS1);
-}
-
-/*
- * Return raw NAND interrupts status
- */
-static inline u32 lpc313x_nand_raw_get(void) {
-	return nand_readl(IRQSTATUSRAW1);
-}
-
-/*
- * Wait for NAND event
- */
-static inline void lpc313x_wait_irq(struct lpc313x_nand_info *host) {
-	wait_event(host->irq_waitq, host->intspending);
-}
-
-/*
- * Handle the NAND interrupt
- */
-static irqreturn_t lpc313x_nandc_irq(int irq, void *dev_id)
-{
-	/* IRQs not working yet */
-	struct lpc313x_nand_info *host = (struct lpc313x_nand_info *) dev_id;
-
-	/* Disable interrupts for now, but don't clear status yet */
-	host->intspending = lpc313x_nand_int_get();
-	lpc313x_nand_int_dis(~0);
-
-	/* Wakeup pending request */
-	wake_up(&host->irq_waitq);
-
-	return IRQ_HANDLED;
-}
-
-/*
- * Start a RAM read operation on RAM0 or RAM1
- */
-static inline void lpc313x_ram_read(int bufnum) {
-	if (bufnum == 0) {
-		/* Use RAM buffer 0 */
-		nand_writel(CONTROLFLOW, NAND_CTRL_RD_RAM0);
-	}
-	else {
-		/* Use RAM buffer 1 */
-		nand_writel(CONTROLFLOW, NAND_CTRL_RD_RAM1);
-	}
-
-	lpc313x_nand_int_en(nand_buff_dec_mask[bufnum]);
-}
-
-/*
- * Start a RAM write operation on RAM0 or RAM1
- */
-static inline void lpc313x_ram_write(int bufnum) {
-	if (bufnum == 0) {
-		/* Use RAM buffer 0 */
-		nand_writel(CONTROLFLOW, NAND_CTRL_WR_RAM0);
-	}
-	else {
-		/* Use RAM buffer 1 */
-		nand_writel(CONTROLFLOW, NAND_CTRL_WR_RAM1);
-	}
-
-	lpc313x_nand_int_en(nand_buff_wr_mask[bufnum]);
-}
-
-/*
- *
- * NAND driver callbacks
- *
- */
-
-/*
- * Asserts and deasserts chip selects (callback)
- */
-static void lpc313x_nand_select_chip(struct mtd_info *mtd, int chip_sel) {
-	struct nand_chip *chip = mtd->priv;
-	struct lpc313x_nand_mtd *nmtd;
-	struct lpc313x_nand_info *host;
-	int i = 0, cssel = -1;
-
-	nmtd = chip->priv;
-	host = nmtd->host;
-
-	if (chip_sel == -1) {
-		/* De-assert all the chip selects */
-		nand_writel(SETCE, NAND_NANDSETCE_CV_MASK);
-	}
-	else {
-		/* We can determine which chip select should be used by
-		   examining the MTD pointer */
-		while (i < host->platform->nr_devices) {
-			if (mtd == &host->mtds[i].mtd) {
-				/* Match */
-				cssel = i;
-				break;
-			}
-
-			i++;
-		}
-
-		if (cssel >= 0) {
-			host->current_cs = cssel;
-			nand_writel(SETCE,
-				(NAND_NANDSETCE_CV_MASK & NAND_NANDSETCE_CV(cssel)));
-		}
-	}
-}
-
-/*
- * Issue command and address cycles to the chip (callback)
- */
-static void lpc313x_nand_hwcontrol(struct mtd_info *mtd, int cmd, unsigned int ctrl) {
-	(void) mtd;
-	(void) ctrl;
-
-	if (cmd == NAND_CMD_NONE)
-		return;
-
-	if (ctrl & NAND_CLE) {
-		nand_writel(SETCMD, (u32) cmd);
-	}
-	else if (ctrl & NAND_ALE) {
-		nand_writel(SETADDR, (u32) cmd);
-	}
-}
-
-/*
- * Returns NAND busy(0)/ready(!0) status callback
- */
-
-static int lpc313x_nand_devready(struct mtd_info *mtd) {
-	struct nand_chip *chip = mtd->priv;
-	struct lpc313x_nand_mtd *nmtd;
-	struct lpc313x_nand_info *host;
-
-	nmtd = chip->priv;
-	host = nmtd->host;
-
-	return nand_readl(CHECKSTS) & rdymasks[host->current_cs];
-}
-
-#ifdef CONFIG_HARDWARE_ECC
-/*
- * MTD hardware ECC enable callback
- */
-static void lpc313x_nand_enable_hwecc(struct mtd_info *mtd, int mode) {
-	(void) mtd;
-	(void) mode;
-
-	/* Nothing to really do here, ECC is enabled and used by default */
-}
-
-/*
- * MTD ECC data correction callback
- */
-static int lpc313x_nand_correct_data(struct mtd_info *mtd, u_char *dat,
-				     u_char *read_ecc, u_char *calc_ecc)
-{
-	u32 tmp;
-	int errs_corrected = 0;
-
-	(void) mtd;
-	(void) dat;
-	(void) calc_ecc;
-
-	/* Data is corrected in hardware, just verify that data is correct per HW */
-	if ((nand_readl(IRQSTATUSRAW1) & NAND_NANDIRQSTATUS1_ERR_UNR_RAM0) &
-		(read_ecc[OOB_FREE_OFFSET] != 0xFF)) {
-		return -1;
-	}
-
-	/* Generate correction statistics */
-	tmp = lpc313x_nand_raw_get();
-	if (!(tmp & (NAND_NANDIRQSTATUS1_NOERR_RAM0 | NAND_NANDIRQSTATUS1_NOERR_RAM1))) {
-		if (tmp & (NAND_NANDIRQSTATUS1_ERR1_RAM0 | NAND_NANDIRQSTATUS1_ERR1_RAM1)) {
-			errs_corrected = 1;
-		}
-		else if (tmp & (NAND_NANDIRQSTATUS1_ERR2_RAM0 | NAND_NANDIRQSTATUS1_ERR2_RAM1)) {
-			errs_corrected = 2;
-		}
-		else if (tmp & (NAND_NANDIRQSTATUS1_ERR3_RAM0 | NAND_NANDIRQSTATUS1_ERR3_RAM1)) {
-			errs_corrected = 3;
-		}
-		else if (tmp & (NAND_NANDIRQSTATUS1_ERR4_RAM0 | NAND_NANDIRQSTATUS1_ERR4_RAM1)) {
-			errs_corrected = 4;
-		}
-		else if (tmp & (NAND_NANDIRQSTATUS1_ERR5_RAM0 | NAND_NANDIRQSTATUS1_ERR5_RAM1)) {
-			errs_corrected = 5;
-		}
-
-		mtd->ecc_stats.corrected += errs_corrected;
-	}
-	else if (tmp & (NAND_NANDIRQSTATUS1_ERR_UNR_RAM0 | NAND_NANDIRQSTATUS1_ERR_UNR_RAM1)) {
-		mtd->ecc_stats.failed++;
-	}
-
-	return 0;
-}
-
-/*
- * MTD calculate ECC callback
- */
-static int lpc313x_nand_calculate_ecc(struct mtd_info *mtd, const u_char *dat, u_char *ecc_code)
-{
-	(void) mtd;
-	(void) dat;
-	(void) ecc_code;
-
-	/* ECC is calculated automatically in hardware, nothing to do */
-	return 0;
-}
-
-/*
- * Verify a buffer written to hardware against the passed buffer (callback)
- */
-static int lpc313x_nand_verify_hwecc(struct mtd_info *mtd, const uint8_t *buf, int len)
-{
-	struct nand_chip *chip = mtd->priv;
-	struct lpc313x_nand_mtd *nmtd;
-	struct lpc313x_nand_info *host;
-	int i, status = 0, curbuf = 0, bufrdy = -1;
-
-	nmtd = chip->priv;
-	host = nmtd->host;
-
-	/* Read back the data stored in the hardware and check it against the buffer */
-	for (i = 0; i < len; i += chip->ecc.size) {
-		/* Clear all current statuses */
-		lpc313x_nand_int_clear(~0);
-
-		/* Start read into RAM0 or RAM1 */
-#if !defined(STATUS_POLLING)
-		host->intspending = 0;
-#endif
-		lpc313x_ram_read(curbuf);
-
-		/* Compare current buffer while next buffer is loading */
-		if (bufrdy >= 0) {
-			if (memcmp(buf, nand_buff_addr[bufrdy], chip->ecc.size) != 0) {
-				status = -EIO;
-			}
-
-			buf += chip->ecc.size;
-		}
-
-#if defined(STATUS_POLLING)
-		/* Polling for buffer loaded and decoded */
-		while (!((nand_readl(IRQSTATUSRAW1)) & nand_buff_dec_mask[curbuf]));
-
-#else
-		/* Interrupt based wait operation */
-		lpc313x_wait_irq(host);
-#endif
-
-		bufrdy = curbuf;
-		curbuf = 1 - curbuf;
-	}
-
-	/* Compare against buffer */
-	if (memcmp(buf, nand_buff_addr[bufrdy], chip->ecc.size) != 0) {
-		status = -EIO;
-	}
-
-	/* Disable all interrupts */
-	lpc313x_nand_int_dis(~0);
-
-	return status;
-}
-#endif  /* CONFIG_HARDWARE_ECC */
-
-/*
- * 8-bit direct NAND interface read callback
- */
-static void lpc313x_nand_read_buf8(struct mtd_info *mtd, u_char *buf, int len) {
-	struct nand_chip *chip = mtd->priv;
-
-	__raw_readsb(chip->IO_ADDR_R, buf, len);
-}
-
-/*
- * 16-bit direct NAND interface read callback
- */
-static void lpc313x_nand_read_buf16(struct mtd_info *mtd, u_char *buf, int len) {
-	struct nand_chip *chip = mtd->priv;
-
-	len >>= 1;
-	__raw_readsw(chip->IO_ADDR_R, buf, len);
-}
-
-/*
- * 8-bit direct NAND interface write callback
- */
-static void lpc313x_nand_write_buf8(struct mtd_info *mtd, const u_char *buf,
-		int len) {
-	struct nand_chip *chip = mtd->priv;
-
-	__raw_writesb(chip->IO_ADDR_W, buf, len);
-}
-
-/*
- * 16-bit direct NAND interface write callback
- */
-static void lpc313x_nand_write_buf16(struct mtd_info *mtd, const u_char *buf,
-		int len) {
-	struct nand_chip *chip = mtd->priv;
-
-	len >>= 1;
-	__raw_writesw(chip->IO_ADDR_W, buf, len);
-}
-
-
-#ifdef CONFIG_HARDWARE_ECC
-/*
- * Read the payload and OOB data from the device in the hardware storage format
- */
-static int lpc313x_nand_read_page_syndrome(struct mtd_info *mtd, struct nand_chip *chip,
-				   uint8_t *buf)
-{
-	int i, curbuf = 0, bufrdy = -1, eccsize = chip->ecc.size;
-	int eccbytes = chip->ecc.bytes;
-	int eccsteps = chip->ecc.steps;
-	uint8_t *p = buf;
-	uint8_t *oob = chip->oob_poi;
-#ifdef USE_DMA
-	int use_dma = 0;
-	dma_addr_t pmapped = 0, oobmapped = 0;
-	u32 p1 = 0, oob1 = 0;
-#endif
-
-#if !defined(STATUS_POLLING)
-	struct lpc313x_nand_mtd *nmtd;
-	struct lpc313x_nand_info *host;
-
-	nmtd = chip->priv;
-	host = nmtd->host;
-#endif
-
-#ifdef USE_DMA
-	/* Get DMA mappings for buffers */
-	pmapped = lpc313x_nand_dma_map(host, (u32) p, (eccsize * eccsteps), 1);
-	oobmapped = lpc313x_nand_dma_map(host, (u32) oob, (eccbytes * eccsteps), 1);
-	if((oobmapped) && (pmapped)) {
-		p1 = pmapped;
-		oob1 = oobmapped;
-		use_dma = 1;
-	}
-#endif
-
-	for (i = eccsteps; i > 0; i--) {
-		/* Clear all current statuses */
-		lpc313x_nand_int_clear(~0);
-
-		/* Start read into RAM0 or RAM1 */
-#if !defined(STATUS_POLLING)
-		host->intspending = 0;
-#endif
-		lpc313x_ram_read(curbuf);
-
-		/* Read current buffer while next buffer is loading */
-		if (bufrdy >= 0) {
-
-#ifdef USE_DMA
-			/* If DMA mapping succesful, use DMA for transfer.
-			 * Else use memcpy for transfer
-			 * */
-			if(use_dma) {
-				/* Read payload & oob using DMA */
-				lpc313x_nand_dma_sg_tfr(mtd, chip, bufrdy, p1, oob1, 1);
-
-				/* Update buffers offsets */
-				p1 += eccsize;
-				oob1 += eccbytes;
-			}
-			else
-#endif
-			{
-				/* Read payload portion of the transfer */
-				memcpy((void *)p, nand_buff_addr[bufrdy], eccsize);
-				p += eccsize;
-
-				/* Read OOB data portion of the transfer */
-				memcpy((void *)oob, nand_buff_addr[bufrdy] + eccsize, eccbytes);
-				oob += eccbytes;
-			}
-		}
-
-#if defined(STATUS_POLLING)
-		/* Polling for buffer loaded and decoded */
-		while (!((nand_readl(IRQSTATUSRAW1)) & nand_buff_dec_mask[curbuf]));
-
-#else
-		/* Interrupt based wait operation */
-		lpc313x_wait_irq(host);
-#endif
-
-		bufrdy = curbuf;
-		curbuf = 1 - curbuf;
-
-		chip->ecc.correct(mtd, p, oob, NULL);
-	}
-
-#ifdef USE_DMA
-	if(use_dma) {
-		/* Transfer payload & oob using DMA */
-		lpc313x_nand_dma_sg_tfr(mtd, chip, bufrdy, p1, oob1, 1);
-
-		/* Unmap DMA mappings */
-		dma_unmap_single(host->dev, pmapped, (eccsize * eccsteps),
-				DMA_FROM_DEVICE);
-		dma_unmap_single(host->dev, oobmapped, (eccbytes * eccsteps),
-				DMA_FROM_DEVICE);
-	}
-	else
-#endif
-	{
-		/* Read payload portion of the transfer */
-		memcpy((void *)p, nand_buff_addr[bufrdy], eccsize);
-
-		/* Read OOB data portion of the transfer */
-		memcpy((void *)oob, nand_buff_addr[bufrdy] + eccsize, eccbytes);
-	}
-
-	/* Disable all interrupts */
-	lpc313x_nand_int_dis(~0);
-
-	return 0;
-}
-
-/*
- * Read the OOB data from the device in the hardware storage format
- */
-static int lpc313x_nand_read_oob_syndrome(struct mtd_info *mtd, struct nand_chip *chip,
-				  int page, int sndcmd)
-{
-	uint8_t *buf = chip->oob_poi;
-	int length = mtd->oobsize;
-	int chunk = chip->ecc.bytes + chip->ecc.prepad + chip->ecc.postpad;
-	int eccsize = chip->ecc.size, eccsteps = chip->ecc.steps;
-	uint8_t *bufpoi = buf;
-	int i, toread, sndrnd = sndcmd, pos;
-
-	chip->cmdfunc(mtd, NAND_CMD_READ0, chip->ecc.size, page);
-	for (i = eccsteps; i > 0; i--) {
-		/* Random position read needed? */
-		if (sndrnd) {
-			pos = eccsize + i * (eccsize + chunk);
-			if (mtd->writesize > 512)
-				chip->cmdfunc(mtd, NAND_CMD_RNDOUT, pos, -1);
-			else
-				chip->cmdfunc(mtd, NAND_CMD_READ0, pos, page);
-		} else {
-			sndrnd = 1;
-		}
-
-		toread = min_t(int, length, chunk);
-		chip->read_buf(mtd, bufpoi, toread);
-		bufpoi += toread;
-		length -= toread;
-	}
-	if (length > 0)
-		chip->read_buf(mtd, bufpoi, length);
-
-	return 1;
-}
-
-/*
- * Write the payload and OOB data to the device in the hardware storage format
- */
-static void lpc313x_nand_write_page_syndrome(struct mtd_info *mtd,
-				    struct nand_chip *chip, const uint8_t *buf)
-{
-	int i, curbuf = 0, bufrdy = 0, eccsize = chip->ecc.size;
-	int eccbytes = chip->ecc.bytes;
-	int eccsteps = chip->ecc.steps;
-	const uint8_t *p = buf;
-	uint8_t *oob = chip->oob_poi;
-#ifdef USE_DMA
-	dma_addr_t pmapped, oobmapped;
-	u32 p1 = 0, oob1 = 0;
-	int use_dma = 0;
-#endif
-
-#if !defined(STATUS_POLLING)
-	struct lpc313x_nand_mtd *nmtd;
-	struct lpc313x_nand_info *host;
-
-	nmtd = chip->priv;
-	host = nmtd->host;
-#endif
-
-#ifdef USE_DMA
-	pmapped = lpc313x_nand_dma_map(host, (u32) p, (eccsize * eccsteps), 0);
-	oobmapped = lpc313x_nand_dma_map(host, (u32) oob, (eccbytes * eccsteps), 0);
-	if((pmapped) && (oobmapped)) {
-		use_dma = 1;
-		p1 = pmapped;
-		oob1 = oobmapped;
-	}
-#endif
-
-	/* Clear all current statuses */
-	lpc313x_nand_int_clear(~0);
-#ifdef USE_DMA
-	/* If DMA mapping succesful, use DMA for transfer.
-	 * Else use memcpy for transfer
-	 * */
-	if(use_dma) {
-		/* Transfer pay load & OOB using DMA */
-		lpc313x_nand_dma_sg_tfr(mtd, chip, bufrdy, p1, oob1, 0);
-
-		/* Update buffer offsets */
-		p1 += eccsize;
-		oob1 += eccbytes;
-	}
-	else
-#endif
-	{
-		/* Copy payload and OOB data to the buffer */
-		memcpy((void *) nand_buff_addr[bufrdy], p, eccsize);
-		memcpy((void *) nand_buff_addr[bufrdy] + eccsize, oob, OOB_FREE_OFFSET);
-		p += eccsize;
-		oob += eccbytes;
-	}
-
-	while(!((nand_readl(IRQSTATUSRAW1)) & nand_buff_enc_mask[bufrdy]));
-
-	for (i = eccsteps; i > 0; i--) {
-		/* Buffer management */
-		curbuf = bufrdy;
-		bufrdy = 1 - bufrdy;
-
-		/* Start the transfer to the device */
-		lpc313x_nand_int_clear(~0);
-#if !defined(STATUS_POLLING)
-		host->intspending = 0;
-#endif
-		lpc313x_ram_write(curbuf);
-
-		/* Copy next payload and OOB data to the buffer while current
-		   buffer is transferring */
-		if (i > 1) {
-
-#ifdef USE_DMA
-			/* If DMA mapping succesful, use DMA for transfer.
-			 * Else use memcpy for transfer
-			 * */
-			if(use_dma) {
-				/* Transfer pay load & OOB using DMA */
-				lpc313x_nand_dma_sg_tfr(mtd, chip, bufrdy, p1, oob1, 0);
-
-				/* Update buffer offsets */
-				p1 += eccsize;
-				oob1 += eccbytes;
-			}
-			else
-#endif
-			{
-				memcpy((void *) nand_buff_addr[bufrdy], p, eccsize);
-				memcpy((void *) nand_buff_addr[bufrdy] + eccsize, oob, OOB_FREE_OFFSET);
-				p += eccsize;
-				oob += eccbytes;
-			}
-			while(!((nand_readl(IRQSTATUSRAW1)) & nand_buff_enc_mask[bufrdy]));
-		}
-
-#if defined(STATUS_POLLING)
-		/* Polling for buffer loaded and decoded */
-		while (!((nand_readl(IRQSTATUSRAW1)) & nand_buff_wr_mask[curbuf]));
-
-#else
-		/* Interrupt based wait operation */
-		lpc313x_wait_irq(host);
-#endif
-	}
-
-	/* Calculate remaining oob bytes */
-	i = mtd->oobsize - (oob - chip->oob_poi);
-	if (i)
-		chip->write_buf(mtd, oob, i);
-
-#ifdef USE_DMA
-	/* Unmap DMA mappings */
-	if(use_dma) {
-		dma_unmap_single(host->dev, pmapped, (eccsize * eccsteps),
-				DMA_TO_DEVICE);
-		dma_unmap_single(host->dev, oobmapped, (eccbytes * eccsteps),
-				DMA_TO_DEVICE);
-	}
-#endif
-
-	/* Disable all interrupts */
-	lpc313x_nand_int_dis(~0);
-}
-
-/*
- * Write the OOB data to the device in the hardware storage format
- */
-static int lpc313x_nand_write_oob_syndrome(struct mtd_info *mtd,
-				   struct nand_chip *chip, int page)
-{
-	int chunk = chip->ecc.bytes + chip->ecc.prepad + chip->ecc.postpad;
-	int eccsize = chip->ecc.size, length = mtd->oobsize;
-	int i, len, pos, status = 0, sndcmd = 0, steps = chip->ecc.steps;
-	const uint8_t *bufpoi = chip->oob_poi;
-
-	pos = eccsize;
-
-	chip->cmdfunc(mtd, NAND_CMD_SEQIN, pos, page);
-	for (i = 0; i < steps; i++) {
-		if (sndcmd) {
-			if (mtd->writesize <= 512) {
-				uint32_t fill = 0xFFFFFFFF;
-
-				len = eccsize;
-				while (len > 0) {
-					int num = min_t(int, len, 4);
-					chip->write_buf(mtd, (uint8_t *)&fill,
-							num);
-					len -= num;
-				}
-			} else {
-				pos = eccsize + i * (eccsize + chunk);
-				chip->cmdfunc(mtd, NAND_CMD_RNDIN, pos, -1);
-			}
-		} else {
-			sndcmd = 1;
-		}
-
-		len = min_t(int, length, chunk);
-		chip->write_buf(mtd, bufpoi, len);
-		bufpoi += len;
-		length -= len;
-	}
-	if (length > 0)
-		chip->write_buf(mtd, bufpoi, length);
-
-	chip->cmdfunc(mtd, NAND_CMD_PAGEPROG, -1, -1);
-	status = chip->waitfunc(mtd, chip);
-
-	return status & NAND_STATUS_FAIL ? -EIO : 0;
-}
-#endif  /* CONFIG_HARDWARE_ECC */
-
-/*
- * Add MTD partitions and a single MTD device
- */
-static int lpc313x_nand_add_partition(struct lpc313x_nand_info *host,
-		struct lpc313x_nand_mtd *bmtd, struct lpc313x_nand_dev_info *device)
-{
-	struct mtd_info *mtd = &bmtd->mtd;
-
-#ifdef CONFIG_MTD_PARTITIONS
-	struct mtd_partition *partitions = NULL;
-	int num_partitions = 0;
-
-#ifdef CONFIG_MTD_CMDLINE_PARTS
-	const char *part_probes[] = {"cmdlinepart", NULL};
-
-	/* Check for partitions from the CMDLINE first, these will override the
-	   board specific partitions */
-	mtd->name = "lpc313x_nand";
-	num_partitions = parse_mtd_partitions(mtd, part_probes,
-					      &partitions, 0);
-#endif
-
-	if ((num_partitions <= 0) && (device->partitions))
-	{
-		/* No CMDLINE partitions, try board specific partitions */
-		partitions = device->partitions;
-		num_partitions = device->nr_partitions;
-	}
-
-	if ((!partitions) || (num_partitions == 0)) {
-		dev_dbg(host->dev, "No parititions defined\n");
-		return ENXIO;
-	}
-
-	return add_mtd_partitions(mtd, partitions, num_partitions);
-
-#else
-	return add_mtd_device(mtd);
-#endif
-}
-
-/*
- * Init a single instance of an chip
- */
-static void lpc313x_nand_init_chip(struct lpc313x_nand_info *host,
-				struct lpc313x_nand_mtd *nmtd) {
-	struct nand_chip *chip = &nmtd->chip;
-
-	if (host->platform->support_16bit) {
-		chip->write_buf = lpc313x_nand_write_buf16;
-		chip->read_buf = lpc313x_nand_read_buf16;
-	}
-	else {
-		chip->write_buf = lpc313x_nand_write_buf8;
-		chip->read_buf = lpc313x_nand_read_buf8;
-	}
-	chip->select_chip = lpc313x_nand_select_chip;
-	chip->chip_delay = 20;
-	chip->priv = nmtd;
-	chip->controller = &host->controller;
-
-	chip->IO_ADDR_W = (void *) &NAND_WRITEDATA;
-	chip->cmd_ctrl = lpc313x_nand_hwcontrol;
-	chip->dev_ready = lpc313x_nand_devready;
-	chip->IO_ADDR_R = (void *) &NAND_READDATA;
-
-	nmtd->host = host;
-	nmtd->mtd.priv = chip;
-	nmtd->mtd.owner = THIS_MODULE;
-	chip->options |= NAND_USE_FLASH_BBT;
-
-#ifdef CONFIG_HARDWARE_ECC
-	chip->ecc.mode = NAND_ECC_HW_SYNDROME;
-	chip->ecc.read_page_raw = lpc313x_nand_read_page_syndrome;
-	chip->ecc.read_page = lpc313x_nand_read_page_syndrome;
-	chip->ecc.write_page = lpc313x_nand_write_page_syndrome;
-	chip->ecc.write_oob = lpc313x_nand_write_oob_syndrome;
-	chip->ecc.read_oob = lpc313x_nand_read_oob_syndrome;
-	chip->ecc.calculate = lpc313x_nand_calculate_ecc;
-	chip->ecc.correct   = lpc313x_nand_correct_data;
-	chip->ecc.hwctl = lpc313x_nand_enable_hwecc;
-
-	chip->verify_buf = lpc313x_nand_verify_hwecc;
-
-	/* Assume large block FLASH for now, will adjust after detection */
-	chip->ecc.layout = &nand_hw_eccoob_64;
-#else
-	chip->ecc.mode = NAND_ECC_SOFT;
-#endif		
-	if (host->platform->support_16bit) {
-		chip->options |= NAND_BUSWIDTH_16;
-	}
-}
-
-/*
- * Post-probe chip update, to change any items, such as the
- * layout for large page nand
- */
-static void lpc313x_nand_update_chip(struct lpc313x_nand_info *info,
-		struct lpc313x_nand_mtd *nmtd) {
-	struct nand_chip *chip = &nmtd->chip;
-
-	chip->bbt_td = &lpc313x_bbt_main_descr;
-	chip->bbt_md = &lpc313x_bbt_mirror_descr;
-
-	/* Select bad block algorithm and ECC layout based on whether
-	   small, large, or huge block FLASH is used */
-#ifdef CONFIG_HARDWARE_ECC
-	if (chip->page_shift <= 10) {
-		/* Small block FLASH */
-		chip->ecc.layout = &nand_hw_eccoob_16;
-		// FIXME unknown if this works
-	} else
-#ifdef HUGE_BLOCK_SUPPORT
-	if (chip->page_shift >= 13) {
-		/* Huge block FLASH */
-		chip->ecc.layout = &nand_hw_eccoob_128;
-		// FIXME bad block descriptors for huge block FLASH not done
-	} else
-#endif
-	{
-		/* Large block FLASH */
-		chip->ecc.layout = &nand_hw_eccoob_64;
-		chip->badblock_pattern = &lpc313x_largepage_flashbased;
-	}
-
-	/* These sizes remain the same regardless of page/block size */
-	chip->ecc.size = 512;
-	chip->ecc.bytes = 16;
-	chip->ecc.prepad = 0;
-#endif
-}
-
-/*
- * Called by device layer when it finds a device matching
- * one our driver can handled. This code checks to see if
- * it can allocate all necessary resources then calls the
- * nand layer to look for devices.
- */
-static int lpc313x_nand_probe(struct platform_device *pdev) {
-	struct lpc313x_nand_info *host = NULL;
-	struct lpc313x_nand_cfg *plat = pdev->dev.platform_data;
-	int irq, scan_res, mtdsize, i, err = 0;
-
-	/* Get required resources */
-	irq = platform_get_irq(pdev, 0);
-	if ((irq < 0) | (irq >= NR_IRQS))
-	{
-		return -EBUSY;
-	}
-
-	host = kmalloc(sizeof (struct lpc313x_nand_info), GFP_KERNEL);
-	if (host == NULL) {
-		dev_err(&pdev->dev, "No memory for flash info\n");
-		err = -ENOMEM;
-		goto exit_error;
-	}
-
-	memset(host, 0, sizeof(*host));
-	/* Register driver data with platform */
-	platform_set_drvdata(pdev, host);
-
-	host->dev = &pdev->dev;
-	host->platform = plat;
-	host->irq = irq;
-	host->current_cs = 0;
-
-	/* Exit if no platform data */
-	if (plat == NULL) {
-		dev_err(&pdev->dev, "No memory for flash info\n");
-		goto exit_error;
-	}
-
-	/* Initialize lock and queue used by higher level NAND driver */
-	spin_lock_init(&host->controller.lock);
-	init_waitqueue_head(&host->controller.wq);
-
-	/* Enable clocks for NAND Controller */
-	lpc313x_nand_clocks_disen(1);
-
-	/* Reset NAND controller */
-	cgu_soft_reset_module(NANDFLASH_CTRL_NAND_RESET_N_SOFT);
-	cgu_soft_reset_module(NANDFLASH_CTRL_ECC_RESET_N_SOFT);
-
-	/* Needed for LPC315x series only */
-	cgu_soft_reset_module(NANDFLASH_CTRL_AES_RESET_N_SOFT);
-
-	/* check NAND mux signals */
-	sys_writel(MUX_NAND_MCI, 0);
-
-
-#ifdef CONFIG_HARDWARE_ECC
-	/* Setup NAND configuration */
-	if (plat->support_16bit) {
-		/* 16-bit mode */
-		host->nandconfig = NAND_NANDCONFIG_DC | NAND_NANDCONFIG_ECGC |
-			NAND_NANDCONFIG_EC | NAND_NANDCONFIG_WD;
-	}
-	else {
-		/* 8-bit mode */
-		host->nandconfig = NAND_NANDCONFIG_DC | NAND_NANDCONFIG_ECGC |
-			NAND_NANDCONFIG_EC;
-	}
-#endif
-
-	/* Initialize the hardware */
-	err = lpc313x_nand_inithw(host);
-	if (err != 0)
-		goto exit_error;
-
-	/* Attach interrupt handler */
-	err = request_irq(host->irq, lpc313x_nandc_irq,
-		IRQF_DISABLED, "nandirq", host);
-	if (err)
-	{
-		goto exit_error;
-	}
-
-	/* IRQ event queue */
-	init_waitqueue_head(&host->irq_waitq);
-
-	/* Allocate space for the MTD data */
-	mtdsize = sizeof(struct lpc313x_nand_mtd) * host->platform->nr_devices;
-	host->mtds = kmalloc(mtdsize, GFP_KERNEL);
-	if (host->mtds == NULL) {
-		dev_err(&pdev->dev, "Failed to allocate mtd storage\n");
-		err = -ENOMEM;
-		goto exit_error2;
-	}
-	memset(host->mtds, 0, mtdsize);
-
-#ifdef USE_DMA
-	/* Allocate sg channel for DMA transfers */
-	host->dma_chn = dma_request_sg_channel("NAND", 0, 0,
-			lpc313x_nand_dma_irq, host, 0);
-	if(host->dma_chn < 0) {
-		dev_err(&pdev->dev, "Failed to allocate DMA SG channel\n");
-		err = host->dma_chn;
-		goto exit_error3;
-	}
-
-	/* Allocate memory for SG Table */
-	host->sg_cpu = dma_alloc_coherent(&pdev->dev,
-			NAND_DMA_MAX_DESC * sizeof(dma_sg_ll_t), &host->sg_dma, GFP_KERNEL);
-	if (host->sg_cpu == NULL) {
-		dev_err(&pdev->dev, "could not alloc dma memory\n");
-		goto exit_error4;
-	}
-
-	/* Initialise DMA wait queue */
-	init_waitqueue_head(&host->dma_waitq);
-#endif
-
-	/* Add MTDs and partitions */
-	for (i = 0; i < host->platform->nr_devices; i++) {
-		dev_dbg(&pdev->dev, "Initializing NAND device on CS%d (%s)\n",
-			i, host->platform->devices[i].name);
-
-		/* Populdate device callbacks used by MTD driver */
-		lpc313x_nand_init_chip(host, &host->mtds[i]);
-
-		/* Scan NAND flash device */
-		scan_res = nand_scan_ident(&host->mtds[i].mtd, 1);
-
-		/* Continue if a device is found */
-		if (scan_res == 0) {
-			/* Update callbacks based on NAND sizing data */
-			lpc313x_nand_update_chip(host, &host->mtds[i]);
-
-			/* Post architecture MTD init */
-			nand_scan_tail(&host->mtds[i].mtd);
-
-			/* Add partitions and MTD device */
-			if (lpc313x_nand_add_partition(host, &host->mtds[i],
-				(plat->devices + i)) < 0) {
-				nand_release(&host->mtds[i].mtd);
-			}
-		}
-		else {
-			dev_dbg(&pdev->dev, "No device detected on CS%d (%s)\n",
-				i, host->platform->devices[i].name);
-		}
-	}
-
-	return 0;
-
-#ifdef USE_DMA
-exit_error4:
-	/* Release sg channel */
-	dma_release_sg_channel(host->dma_chn);
-
-exit_error3:
-	/* Release memory */
-	if(host->mtds != NULL)
-		kfree(host->mtds);
-#endif
-
-exit_error2:
-	/* Release IRQ */
-	free_irq(host->irq, pdev);
-
-exit_error:
-	if (host != NULL)
-		kfree(host);
-
-	/* Disable clocks for NAND Controller */
-	lpc313x_nand_clocks_disen(0);
-
-	return err;
-}
-
-/*
- * Device removal
- */
-static int lpc313x_nand_remove(struct platform_device *pdev) {
-	struct lpc313x_nand_info *host = platform_get_drvdata(pdev);
-	int i;
-
-	platform_set_drvdata(pdev, NULL);
-
-	if (host == NULL)
-		return 0;
-
-	/* Release all the MTDs */
-	for (i = 0; i < host->platform->nr_devices; i++) {
-		dev_dbg(&pdev->dev, "Releasing mtd device %d (%s)\n", i,
-			host->platform->devices[i].name);
-		nand_release(&host->mtds[i].mtd);
-	}
-
-	/* Disable clocks for NAND Controller */
-	lpc313x_nand_clocks_disen(1);
-
-#ifdef USE_DMA
-	/* Release memory allocated for SG table */
-	dma_free_coherent(host->dev, NAND_DMA_MAX_DESC * sizeof(dma_sg_ll_t),
-			host->sg_cpu, host->sg_dma);
-
-	/* Release sg channel */
-	dma_release_sg_channel(host->dma_chn);
-#endif
-
-	/* Release IRQ */
-	free_irq(host->irq, pdev);
-
-	kfree(host->mtds);
-	kfree(host);
-
-	return 0;
-}
-
-#if defined(CONFIG_PM)
-static int lpc313x_nand_resume(struct platform_device *pdev)
-{
-	/* Enables clocks for NAND Controller */
-	lpc313x_nand_clocks_disen(1);
-
-	return 0;
-}
-
-static int lpc313x_nand_suspend(struct platform_device *pdev, pm_message_t pm)
-{
-	/* Disable clocks for NAND Controller */
-	lpc313x_nand_clocks_disen(0);
-
-	return 0;
-}
-
-#else
-#define lpc313x_nand_resume NULL
-#define lpc313x_nand_suspend NULL
-#endif
-
-static struct platform_driver lpc313x_nand_driver = {
-	.probe		= lpc313x_nand_probe,
-	.remove		= lpc313x_nand_remove,
-	.resume		= lpc313x_nand_resume,
-	.suspend	= lpc313x_nand_suspend,
-	.driver = {
-		.name = "lpc313x_nand",
-		.owner = THIS_MODULE,
-	},
-};
-
-static int __init lpc313x_nand_init(void)
-{
-	return platform_driver_register(&lpc313x_nand_driver);
-}
-
-static void __exit lpc313x_nand_exit(void)
-{
-	platform_driver_unregister(&lpc313x_nand_driver);
-}
-
-module_init( lpc313x_nand_init);
-module_exit( lpc313x_nand_exit);
-
-MODULE_DESCRIPTION("LPC313x NAND Controller driver");
-MODULE_AUTHOR("NXP Semiconductor VietNam");
-MODULE_LICENSE("GPL v2");
-
diff --exclude CVS --exclude .git -uNr linux-2.6.33/sound/soc/lpc313x/lpc313x-i2s.c linux-2.6.33.modified/sound/soc/lpc313x/lpc313x-i2s.c
--- linux-2.6.33/sound/soc/lpc313x/lpc313x-i2s.c	2012-10-01 21:38:07.173094244 -0700
+++ linux-2.6.33.modified/sound/soc/lpc313x/lpc313x-i2s.c	2012-10-01 21:33:37.691079749 -0700
@@ -297,14 +297,8 @@
 	return 0;
 }
 
-static int lpc313x_i2s_prepare(struct snd_pcm_substream *substream)
-{
-	/* Nothing to do here */
-	return 0;
-}
-
-
-static int lpc313x_i2s_trigger(struct snd_pcm_substream *substream, int cmd)
+static int lpc313x_i2s_trigger(struct snd_pcm_substream *substream, int cmd,
+                               struct snd_soc_dai *dai)
 {
 	int ret = 0;
 
